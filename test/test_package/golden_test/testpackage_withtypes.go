// DO NOT EDIT
// Code generated by smock 

package testpackage_mock

import (
	"fmt"
	"reflect"
)

func NewMockWithTypes[T any, B any](t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockWithTypes[T, B] {
	return &MockWithTypes[T, B]{t: t}
}

type MockWithTypes[T any, B any] struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	
	vFoo []*struct{fun func(a T, b T) (r0 B); validateArgs func(a T, b T) bool}
	vEmpty []*struct{fun func(); validateArgs func() bool}
}

func (m *MockWithTypes[T, B]) Foo(a T, b T) (r0 B) {
	for _, check := range m.vFoo {
		if check.validateArgs == nil || check.validateArgs(a, b) {
			return check.fun(a, b)
		}
	}
	m.unexpectedCall("Foo", a, b)
	return
}

func (m *MockWithTypes[T, B]) Empty() {
	for _, check := range m.vEmpty {
		if check.validateArgs == nil || check.validateArgs() {
			check.fun()
			return
		}
	}
	m.unexpectedCall("Empty", )
}

func (m *MockWithTypes[T, B]) unexpectedCall(method string, args ...any) {
	argsStr := ""
	for idx, arg := range args {
		t := reflect.TypeOf(arg)
		if t.Kind() == reflect.Func {
			argsStr += fmt.Sprintf("%T", t)
		} else {
			argsStr += fmt.Sprintf("%+v", t)
		}
		if idx+1 < len(args) {
			argsStr += ", "
		}
	}
	m.t.Helper()
	m.t.Fatalf(`Unexpected call to MockWithTypes.%s(%s)`, method, argsStr)
}

func (m *MockWithTypes[T, B]) WHEN() *MockWithTypesWhen[T, B] {
	return &MockWithTypesWhen[T, B]{
		m: m,
	}
}

type MockWithTypesWhen[T any, B any] struct {
	m *MockWithTypes[T, B]
}

func (mh *MockWithTypesWhen[T, B]) Foo() *MockWithTypesFooArgs[T, B] {
	for _, f := range  mh.m.vFoo {
		if f.validateArgs == nil {
			mh.m.t.Helper()
			mh.m.t.Fatalf("Unreachable condition. Call to 'Foo' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(a T, b T) (r0 B)
		validateArgs func(a T, b T) bool
	}
	validator.fun = func(a T, b T) (r0 B) { return }
	mh.m.vFoo = append(mh.m.vFoo, &validator)
	return &MockWithTypesFooArgs[T, B] {
		MockWithTypesFooArgsEval: MockWithTypesFooArgsEval[T, B]{fun: &validator.fun},
		validateArgs: &validator.validateArgs,
		fun: &validator.fun,
	}
}

type MockWithTypesFooArgs[T any, B any] struct {
	MockWithTypesFooArgsEval[T, B]
	fun *func(a T, b T) (r0 B)
	validateArgs *func(a T, b T) bool
}

func (f *MockWithTypesFooArgs[T, B]) ExpectArgs(matcha interface{Match(T) bool}, matchb interface{Match(T) bool}) *MockWithTypesFooArgsEval[T, B] {
	if !(matcha == nil && matchb == nil) {
		*f.validateArgs = func(a T, b T) bool {
			return (matcha == nil || matcha.Match(a)) && (matchb == nil || matchb.Match(b))
		}
	}
	return &f.MockWithTypesFooArgsEval
}

type MockWithTypesFooArgsEval[T any, B any] struct {
	fun *func(a T, b T) (r0 B)
}

func (f *MockWithTypesFooArgsEval[T, B]) Return(r0 B) {
	*f.fun = func(T, T) (B) { return r0 }
}

func (f *MockWithTypesFooArgsEval[T, B]) Do(do func(a T, b T) (r0 B)) {
	*f.fun = do
}

func (mh *MockWithTypesWhen[T, B]) Empty() *MockWithTypesEmptyArgsEval[T, B] {
	for _, f := range  mh.m.vEmpty {
		if f.validateArgs == nil {
			mh.m.t.Helper()
			mh.m.t.Fatalf("Unreachable condition. Call to 'Empty' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func()
		validateArgs func() bool
	}
	validator.fun = func() { }
	mh.m.vEmpty = append(mh.m.vEmpty, &validator)
	return &MockWithTypesEmptyArgsEval[T, B] {
		fun: &validator.fun,
	}
}

type MockWithTypesEmptyArgsEval[T any, B any] struct {
	fun *func()
}

func (f *MockWithTypesEmptyArgsEval[T, B]) Do(do func()) {
	*f.fun = do
}
