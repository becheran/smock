// DO NOT EDIT
// Code generated by smock 

package testpackage_mock

import (
	fmt "fmt"
	reflect "reflect"
	testpackage "github.com/test/testpackage"
)

// MockSimple must implement interface testpackage.Simple
var _ testpackage.Simple = &MockSimple{}

// NewMockSimple creates a new mock object which implements the corresponding interface.
// All function calls can be mocked with a custom behavior for tests using the WHEN function on the mock object.   
func NewMockSimple(t interface {
	Fatalf(format string, args ...any)
	Helper()
	Cleanup(f func())
}) *MockSimple {
	t.Helper()
	m := &MockSimple{t: t}
	t.Cleanup(func () {
		errStr := ""
		for _, v := range m.vFoo {
			if v.expectedCalled >= 0 && v.expectedCalled != v.called {
				errStr += fmt.Sprintf("\nExpected 'Foo' to be called %d times, but was called %d times.", v.expectedCalled, v.called)
			}
		}
		for _, v := range m.vSingleArg {
			if v.expectedCalled >= 0 && v.expectedCalled != v.called {
				errStr += fmt.Sprintf("\nExpected 'SingleArg' to be called %d times, but was called %d times.", v.expectedCalled, v.called)
			}
		}
		for _, v := range m.vBar {
			if v.expectedCalled >= 0 && v.expectedCalled != v.called {
				errStr += fmt.Sprintf("\nExpected 'Bar' to be called %d times, but was called %d times.", v.expectedCalled, v.called)
			}
		}
		for _, v := range m.vBaz {
			if v.expectedCalled >= 0 && v.expectedCalled != v.called {
				errStr += fmt.Sprintf("\nExpected 'Baz' to be called %d times, but was called %d times.", v.expectedCalled, v.called)
			}
		}
		for _, v := range m.vFun {
			if v.expectedCalled >= 0 && v.expectedCalled != v.called {
				errStr += fmt.Sprintf("\nExpected 'Fun' to be called %d times, but was called %d times.", v.expectedCalled, v.called)
			}
		}
		if errStr != "" {
			t.Helper()
			t.Fatalf(errStr)
		}
	})
	return m
}

type MockSimple struct {
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
	
	vFoo []*struct{fun func(); validateArgs func() bool; expectedCalled int; called int}
	vSingleArg []*struct{fun func(i0 int); validateArgs func(i0 int) bool; expectedCalled int; called int}
	vBar []*struct{fun func(a int, b string, c struct{}, d *struct{}, e any, f []byte) (r0 string); validateArgs func(a int, b string, c struct{}, d *struct{}, e any, f []byte) bool; expectedCalled int; called int}
	vBaz []*struct{fun func(a int, b string) (s string); validateArgs func(a int, b string) bool; expectedCalled int; called int}
	vFun []*struct{fun func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) (r func(), r2 func()); validateArgs func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) bool; expectedCalled int; called int}
}

func (_this *MockSimple) Foo() {
	for _, _check := range _this.vFoo {
		if _check.validateArgs == nil || _check.validateArgs() {
			_check.called++
			_check.fun()
			return
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Foo", )
}

func (_this *MockSimple) SingleArg(i0 int) {
	for _, _check := range _this.vSingleArg {
		if _check.validateArgs == nil || _check.validateArgs(i0) {
			_check.called++
			_check.fun(i0)
			return
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("SingleArg", i0)
}

func (_this *MockSimple) Bar(a int, b string, c struct{}, d *struct{}, e any, f []byte) (r0 string) {
	for _, _check := range _this.vBar {
		if _check.validateArgs == nil || _check.validateArgs(a, b, c, d, e, f) {
			_check.called++
			return _check.fun(a, b, c, d, e, f)
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Bar", a, b, c, d, e, f)
	return
}

func (_this *MockSimple) Baz(a int, b string) (s string) {
	for _, _check := range _this.vBaz {
		if _check.validateArgs == nil || _check.validateArgs(a, b) {
			_check.called++
			return _check.fun(a, b)
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Baz", a, b)
	return
}

func (_this *MockSimple) Fun(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) (r func(), r2 func()) {
	for _, _check := range _this.vFun {
		if _check.validateArgs == nil || _check.validateArgs(a, b) {
			_check.called++
			return _check.fun(a, b)
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Fun", a, b)
	return
}

func (_this *MockSimple) unexpectedCall(method string, args ...any) {
	argsStr := ""
	for idx, arg := range args {
		switch t := reflect.TypeOf(arg); {
		case t.Kind() == reflect.Func:
			argsStr += fmt.Sprintf("%T", t)
		case t.Kind() == reflect.String:
			argsStr += fmt.Sprintf("%q", arg)
		default:
			argsStr += fmt.Sprintf("%+v", arg)
		}
		if idx+1 < len(args) {
			argsStr += ", "
		}
	}
	_this.t.Helper()
	_this.t.Fatalf(`Unexpected call to %s(). If function call is expected add ".WHEN.%s()" to mock.`, method, method)
}

// WHEN is used to set the mock behavior when a specific functions on the object are called.
// Use this to setup your mock for your specific test scenario.
func (_this *MockSimple) WHEN() *MockSimpleWhen {
	return &MockSimpleWhen{
		m: _this,
	}
}

type MockSimpleWhen struct {
	m *MockSimple
}

// Defines the behavior when Foo of the mock is called.
//
// As a default the method can be called any times.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Foo() *MockSimpleFooWhen {
	for _, f := range _this.m.vFoo {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Foo' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func()
		validateArgs func() bool
		expectedCalled int
		called int
	}
	validator.fun = func() {}
	validator.expectedCalled = -1
	_this.m.vFoo = append(_this.m.vFoo, &validator)
	return &MockSimpleFooWhen{fun: &validator.fun, MockSimpleTimes: &MockSimpleTimes{expectedCalled: &validator.expectedCalled}} 
}

type MockSimpleFooWhen struct {
	*MockSimpleTimes
	fun *func()
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleFooWhen) Do(do func()) *MockSimpleTimes {
	*_this.fun = do
	return _this.MockSimpleTimes
}

// Defines the behavior when SingleArg of the mock is called.
//
// As a default the method can be called any times.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) SingleArg() *MockSimpleSingleArgExpect {
	for _, f := range _this.m.vSingleArg {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'SingleArg' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(i0 int)
		validateArgs func(i0 int) bool
		expectedCalled int
		called int
	}
	validator.fun = func(i0 int) {}
	validator.expectedCalled = -1
	_this.m.vSingleArg = append(_this.m.vSingleArg, &validator)
	return &MockSimpleSingleArgExpect {
		MockSimpleSingleArgWhen: &MockSimpleSingleArgWhen{fun: &validator.fun, MockSimpleTimes: &MockSimpleTimes{expectedCalled: &validator.expectedCalled}},
		validateArgs: &validator.validateArgs,
	}
}

type MockSimpleSingleArgExpect struct {
	*MockSimpleSingleArgWhen
	validateArgs *func(i0 int) bool
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleSingleArgExpect) Expect(_0 func(int) bool) *MockSimpleSingleArgWhen {
	if !(_0 == nil) {
		*_this.validateArgs = func(_i0 int) bool {
			return (_0 == nil || _0(_i0))
		}
	}
	return _this.MockSimpleSingleArgWhen
}

type MockSimpleSingleArgWhen struct {
	*MockSimpleTimes
	fun *func(i0 int)
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleSingleArgWhen) Do(do func(i0 int)) *MockSimpleTimes {
	*_this.fun = do
	return _this.MockSimpleTimes
}

// Defines the behavior when Bar of the mock is called.
//
// As a default the method can be called any times.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Bar() *MockSimpleBarExpect {
	for _, f := range _this.m.vBar {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Bar' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(a int, b string, c struct{}, d *struct{}, e any, f []byte) (r0 string)
		validateArgs func(a int, b string, c struct{}, d *struct{}, e any, f []byte) bool
		expectedCalled int
		called int
	}
	validator.fun = func(a int, b string, c struct{}, d *struct{}, e any, f []byte) (r0 string) { return }
	validator.expectedCalled = -1
	_this.m.vBar = append(_this.m.vBar, &validator)
	return &MockSimpleBarExpect {
		MockSimpleBarWhen: &MockSimpleBarWhen{fun: &validator.fun, MockSimpleTimes: &MockSimpleTimes{expectedCalled: &validator.expectedCalled}},
		validateArgs: &validator.validateArgs,
	}
}

type MockSimpleBarExpect struct {
	*MockSimpleBarWhen
	validateArgs *func(a int, b string, c struct{}, d *struct{}, e any, f []byte) bool
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleBarExpect) Expect(a func(int) bool, b func(string) bool, c func(struct{}) bool, d func(*struct{}) bool, e func(any) bool, f func([]byte) bool) *MockSimpleBarWhen {
	if !(a == nil && b == nil && c == nil && d == nil && e == nil && f == nil) {
		*_this.validateArgs = func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) bool {
			return (a == nil || a(_a)) && (b == nil || b(_b)) && (c == nil || c(_c)) && (d == nil || d(_d)) && (e == nil || e(_e)) && (f == nil || f(_f))
		}
	}
	return _this.MockSimpleBarWhen
}

type MockSimpleBarWhen struct {
	*MockSimpleTimes
	fun *func(a int, b string, c struct{}, d *struct{}, e any, f []byte) (r0 string)
}

// Return the provided values when called
func (_this *MockSimpleBarWhen) Return(r0 string) *MockSimpleTimes {
	*_this.fun = func(int, string, struct{}, *struct{}, any, []byte) (string) { return r0 }
	return _this.MockSimpleTimes
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleBarWhen) Do(do func(a int, b string, c struct{}, d *struct{}, e any, f []byte) (r0 string)) *MockSimpleTimes {
	*_this.fun = do
	return _this.MockSimpleTimes
}

// Defines the behavior when Baz of the mock is called.
//
// As a default the method can be called any times.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Baz() *MockSimpleBazExpect {
	for _, f := range _this.m.vBaz {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Baz' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(a int, b string) (s string)
		validateArgs func(a int, b string) bool
		expectedCalled int
		called int
	}
	validator.fun = func(a int, b string) (s string) { return }
	validator.expectedCalled = -1
	_this.m.vBaz = append(_this.m.vBaz, &validator)
	return &MockSimpleBazExpect {
		MockSimpleBazWhen: &MockSimpleBazWhen{fun: &validator.fun, MockSimpleTimes: &MockSimpleTimes{expectedCalled: &validator.expectedCalled}},
		validateArgs: &validator.validateArgs,
	}
}

type MockSimpleBazExpect struct {
	*MockSimpleBazWhen
	validateArgs *func(a int, b string) bool
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleBazExpect) Expect(a func(int) bool, b func(string) bool) *MockSimpleBazWhen {
	if !(a == nil && b == nil) {
		*_this.validateArgs = func(_a int, _b string) bool {
			return (a == nil || a(_a)) && (b == nil || b(_b))
		}
	}
	return _this.MockSimpleBazWhen
}

type MockSimpleBazWhen struct {
	*MockSimpleTimes
	fun *func(a int, b string) (s string)
}

// Return the provided values when called
func (_this *MockSimpleBazWhen) Return(s string) *MockSimpleTimes {
	*_this.fun = func(int, string) (string) { return s }
	return _this.MockSimpleTimes
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleBazWhen) Do(do func(a int, b string) (s string)) *MockSimpleTimes {
	*_this.fun = do
	return _this.MockSimpleTimes
}

// Defines the behavior when Fun of the mock is called.
//
// As a default the method can be called any times.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Fun() *MockSimpleFunExpect {
	for _, f := range _this.m.vFun {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Fun' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) (r func(), r2 func())
		validateArgs func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) bool
		expectedCalled int
		called int
	}
	validator.fun = func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) (r func(), r2 func()) { return }
	validator.expectedCalled = -1
	_this.m.vFun = append(_this.m.vFun, &validator)
	return &MockSimpleFunExpect {
		MockSimpleFunWhen: &MockSimpleFunWhen{fun: &validator.fun, MockSimpleTimes: &MockSimpleTimes{expectedCalled: &validator.expectedCalled}},
		validateArgs: &validator.validateArgs,
	}
}

type MockSimpleFunExpect struct {
	*MockSimpleFunWhen
	validateArgs *func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) bool
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleFunExpect) Expect(a func(func(func(string, string) (int, int), func(string, string) (int, int))) bool, b func(func(func(string, string) (int, int), func(string, string) (int, int))) bool) *MockSimpleFunWhen {
	if !(a == nil && b == nil) {
		*_this.validateArgs = func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) bool {
			return (a == nil || a(_a)) && (b == nil || b(_b))
		}
	}
	return _this.MockSimpleFunWhen
}

type MockSimpleFunWhen struct {
	*MockSimpleTimes
	fun *func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) (r func(), r2 func())
}

// Return the provided values when called
func (_this *MockSimpleFunWhen) Return(r func(), r2 func()) *MockSimpleTimes {
	*_this.fun = func(func(func(string, string) (int, int), func(string, string) (int, int)), func(func(string, string) (int, int), func(string, string) (int, int))) (func(), func()) { return r, r2 }
	return _this.MockSimpleTimes
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleFunWhen) Do(do func(a func(func(string, string) (int, int), func(string, string) (int, int)), b func(func(string, string) (int, int), func(string, string) (int, int))) (r func(), r2 func())) *MockSimpleTimes {
	*_this.fun = do
	return _this.MockSimpleTimes
}

type MockSimpleTimes struct {
	expectedCalled *int
}

// Times sets how often the mocked function is expected to be called.
// Test will fail if the number of calls do not match with the expected calls value.
//
// A number < 0 means that a function may be called any times which is also the default behavior.
func (_this *MockSimpleTimes) Times(times int) {
	*_this.expectedCalled = times
}

// AnyTimes disables the check how often a function was called.
func (_this *MockSimpleTimes) AnyTimes() {
	*_this.expectedCalled = -1
}

// Never will fail if the function is ever called. Is the same as Times(0).
func (_this *MockSimpleTimes) Never() {
	*_this.expectedCalled = 0
}

// Once will fail if the function is not called once. Is the same as Times(1).
func (_this *MockSimpleTimes) Once() {
	*_this.expectedCalled = 1
}
