// DO NOT EDIT
// Code generated by smock (unknown)

package testpackage_mock

import (
	fmt "fmt"
	reflect "reflect"
	runtime "runtime"
	sync "sync"
)

// NewMockSimple creates a new mock object which implements the corresponding interface.
// All function calls can be mocked with a custom behavior for tests using the WHEN function on the mock object.
// The mock will use the passed in testing.T to report test failures.
func NewMockSimple(t interface {
	Fatalf(format string, args ...any)
	Helper()
	Cleanup(f func())
}) *MockSimple {
	t.Helper()
	m := &MockSimple{t: t}
	t.Cleanup(func () {
		errStr := ""
		for _, v := range m.vFoo {
			for _, c := range v.expected {
				c.mutex.Lock()
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Foo' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
				c.mutex.Unlock()
			}
		}
		for _, v := range m.vSingleArg {
			for _, c := range v.expected {
				c.mutex.Lock()
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'SingleArg' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
				c.mutex.Unlock()
			}
		}
		for _, v := range m.vBar {
			for _, c := range v.expected {
				c.mutex.Lock()
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Bar' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
				c.mutex.Unlock()
			}
		}
		for _, v := range m.vBaz {
			for _, c := range v.expected {
				c.mutex.Lock()
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Baz' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
				c.mutex.Unlock()
			}
		}
		for _, v := range m.vFun {
			for _, c := range v.expected {
				c.mutex.Lock()
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Fun' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
				c.mutex.Unlock()
			}
		}
		if errStr != "" {
			t.Helper()
			t.Fatalf(errStr)
		}})
	return m
}

type MockSimple struct {
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
	
	vFoo []*struct{location string; validateArgs func() bool; expected []*struct{fun func(); expectedCalled int; called int; mutex sync.Mutex}}
	vSingleArg []*struct{location string; validateArgs func(_i0 int) bool; expected []*struct{fun func(_i0 int); expectedCalled int; called int; mutex sync.Mutex}}
	vBar []*struct{location string; validateArgs func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) bool; expected []*struct{fun func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string); expectedCalled int; called int; mutex sync.Mutex}}
	vBaz []*struct{location string; validateArgs func(_a int, _b string) bool; expected []*struct{fun func(_a int, _b string) (_s string); expectedCalled int; called int; mutex sync.Mutex}}
	vFun []*struct{location string; validateArgs func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) bool; expected []*struct{fun func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func()); expectedCalled int; called int; mutex sync.Mutex}}
}

func (_this *MockSimple) Foo() {
	for _, _check := range _this.vFoo {
		if _check.validateArgs == nil || _check.validateArgs() {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					_exp.fun()
					return
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Foo", )
}

func (_this *MockSimple) SingleArg(_i0 int) {
	for _, _check := range _this.vSingleArg {
		if _check.validateArgs == nil || _check.validateArgs(_i0) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					_exp.fun(_i0)
					return
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("SingleArg", _i0)
}

func (_this *MockSimple) Bar(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string) {
	for _, _check := range _this.vBar {
		if _check.validateArgs == nil || _check.validateArgs(_a, _b, _c, _d, _e, _f) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_a, _b, _c, _d, _e, _f)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Bar", _a, _b, _c, _d, _e, _f)
	return
}

func (_this *MockSimple) Baz(_a int, _b string) (_s string) {
	for _, _check := range _this.vBaz {
		if _check.validateArgs == nil || _check.validateArgs(_a, _b) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_a, _b)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Baz", _a, _b)
	return
}

func (_this *MockSimple) Fun(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func()) {
	for _, _check := range _this.vFun {
		if _check.validateArgs == nil || _check.validateArgs(_a, _b) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_a, _b)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Fun", _a, _b)
	return
}

func (_this *MockSimple) unexpectedCall(method string, args ...any) {
	argsStr := ""
	for idx, arg := range args {
		switch t := reflect.TypeOf(arg); {
		case t.Kind() == reflect.Func:
			argsStr += fmt.Sprintf("%T", t)
		case t.Kind() == reflect.String:
			argsStr += fmt.Sprintf("%q", arg)
		default:
			argsStr += fmt.Sprintf("%+v", arg)
		}
		if idx+1 < len(args) {
			argsStr += ", "
		}
	}
	_this.t.Helper()
	_this.t.Fatalf(`Unexpected call to %s(). If function call is expected add ".WHEN.%s()" to mock.`, method, method)
}

// WHEN is used to set the mock behavior when a specific functions on the object are called.
// Use this to setup your mock for your specific test scenario.
func (_this *MockSimple) WHEN() *MockSimpleWhen {
	return &MockSimpleWhen {
		m: _this,
	}
}

type MockSimpleWhen struct {
	m *MockSimple
}

// Defines the behavior when Foo of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Foo() *MockSimpleFooWhenWithTimes {
	for _, f := range _this.m.vFoo {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Foo' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func()
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func() {}
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func() bool
		expected []*struct {
			fun func()
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vFoo = append(_this.m.vFoo, &validator)
	var _then func() *MockSimpleFooWhen
	_then = func() *MockSimpleFooWhen {
		var _newExpected struct {
			fun func()
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func() { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockSimpleFooWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockSimpleTimes[*MockSimpleFooWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleFooWhen]{ then: _then, t: _this.m.t},
	}
	return &MockSimpleFooWhenWithTimes {
		MockSimpleFooWhen: &MockSimpleFooWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		},
		MockSimpleTimes: times,
	}
}

type MockSimpleFooWhen struct {
	expected []*struct {
		fun func()
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockSimpleFooWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockSimpleFooWhenWithTimes struct {
	*MockSimpleTimes[*MockSimpleFooWhen]
	*MockSimpleFooWhen
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleFooWhen) Do(do func()) *MockSimpleTimes[*MockSimpleFooWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockSimpleTimes[*MockSimpleFooWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleFooWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when SingleArg of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) SingleArg() *MockSimpleSingleArgExpectWithTimes {
	for _, f := range _this.m.vSingleArg {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'SingleArg' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_i0 int)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_i0 int) {}
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_i0 int) bool
		expected []*struct {
			fun func(_i0 int)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vSingleArg = append(_this.m.vSingleArg, &validator)
	var _then func() *MockSimpleSingleArgWhen
	_then = func() *MockSimpleSingleArgWhen {
		var _newExpected struct {
			fun func(_i0 int)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_i0 int) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockSimpleSingleArgWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockSimpleTimes[*MockSimpleSingleArgWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleSingleArgWhen]{ then: _then, t: _this.m.t},
	}
	return &MockSimpleSingleArgExpectWithTimes {
		MockSimpleSingleArgExpect: &MockSimpleSingleArgExpect {
			MockSimpleSingleArgWhen: &MockSimpleSingleArgWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockSimpleTimes: times,
	}
}

type MockSimpleSingleArgExpect struct {
	*MockSimpleSingleArgWhen
	validateArgs *func(_i0 int) bool
	times *MockSimpleTimes[*MockSimpleSingleArgWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleSingleArgExpect) Expect(_0 func(int) bool) *MockSimpleSingleArgWhenWithTimes {
	if !(_0 == nil) {
		*_this.validateArgs = func(__i0 int) bool {
			return (_0 == nil || _0(__i0))
		}
	}
	return &MockSimpleSingleArgWhenWithTimes {
		MockSimpleSingleArgWhen: _this.MockSimpleSingleArgWhen,
		MockSimpleTimes: _this.times,
	}
}

type MockSimpleSingleArgExpectWithTimes struct {
	*MockSimpleTimes[*MockSimpleSingleArgWhen]
	*MockSimpleSingleArgExpect
}

type MockSimpleSingleArgWhen struct {
	expected []*struct {
		fun func(_i0 int)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockSimpleSingleArgWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockSimpleSingleArgWhenWithTimes struct {
	*MockSimpleTimes[*MockSimpleSingleArgWhen]
	*MockSimpleSingleArgWhen
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleSingleArgWhen) Do(do func(_i0 int)) *MockSimpleTimes[*MockSimpleSingleArgWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockSimpleTimes[*MockSimpleSingleArgWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleSingleArgWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when Bar of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Bar() *MockSimpleBarExpectWithTimes {
	for _, f := range _this.m.vBar {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Bar' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) bool
		expected []*struct {
			fun func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vBar = append(_this.m.vBar, &validator)
	var _then func() *MockSimpleBarWhen
	_then = func() *MockSimpleBarWhen {
		var _newExpected struct {
			fun func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockSimpleBarWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockSimpleTimes[*MockSimpleBarWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleBarWhen]{ then: _then, t: _this.m.t},
	}
	return &MockSimpleBarExpectWithTimes {
		MockSimpleBarExpect: &MockSimpleBarExpect {
			MockSimpleBarWhen: &MockSimpleBarWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockSimpleTimes: times,
	}
}

type MockSimpleBarExpect struct {
	*MockSimpleBarWhen
	validateArgs *func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) bool
	times *MockSimpleTimes[*MockSimpleBarWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleBarExpect) Expect(_a func(int) bool, _b func(string) bool, _c func(struct{}) bool, _d func(*struct{}) bool, _e func(any) bool, _f func([]byte) bool) *MockSimpleBarWhenWithTimes {
	if !(_a == nil && _b == nil && _c == nil && _d == nil && _e == nil && _f == nil) {
		*_this.validateArgs = func(__a int, __b string, __c struct{}, __d *struct{}, __e any, __f []byte) bool {
			return (_a == nil || _a(__a)) && (_b == nil || _b(__b)) && (_c == nil || _c(__c)) && (_d == nil || _d(__d)) && (_e == nil || _e(__e)) && (_f == nil || _f(__f))
		}
	}
	return &MockSimpleBarWhenWithTimes {
		MockSimpleBarWhen: _this.MockSimpleBarWhen,
		MockSimpleTimes: _this.times,
	}
}

type MockSimpleBarExpectWithTimes struct {
	*MockSimpleTimes[*MockSimpleBarWhen]
	*MockSimpleBarExpect
}

type MockSimpleBarWhen struct {
	expected []*struct {
		fun func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockSimpleBarWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockSimpleBarWhenWithTimes struct {
	*MockSimpleTimes[*MockSimpleBarWhen]
	*MockSimpleBarWhen
}

// Return the provided values when called
func (_this *MockSimpleBarWhen) Return(_r0 string) *MockSimpleTimes[*MockSimpleBarWhen] {
	_this.expected[len(_this.expected) -1].fun = func(int, string, struct{}, *struct{}, any, []byte) (string) { return _r0 }
	return &MockSimpleTimes[*MockSimpleBarWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleBarWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleBarWhen) Do(do func(_a int, _b string, _c struct{}, _d *struct{}, _e any, _f []byte) (_r0 string)) *MockSimpleTimes[*MockSimpleBarWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockSimpleTimes[*MockSimpleBarWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleBarWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when Baz of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Baz() *MockSimpleBazExpectWithTimes {
	for _, f := range _this.m.vBaz {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Baz' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_a int, _b string) (_s string)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_a int, _b string) (_s string) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_a int, _b string) bool
		expected []*struct {
			fun func(_a int, _b string) (_s string)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vBaz = append(_this.m.vBaz, &validator)
	var _then func() *MockSimpleBazWhen
	_then = func() *MockSimpleBazWhen {
		var _newExpected struct {
			fun func(_a int, _b string) (_s string)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_a int, _b string) (_s string) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockSimpleBazWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockSimpleTimes[*MockSimpleBazWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleBazWhen]{ then: _then, t: _this.m.t},
	}
	return &MockSimpleBazExpectWithTimes {
		MockSimpleBazExpect: &MockSimpleBazExpect {
			MockSimpleBazWhen: &MockSimpleBazWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockSimpleTimes: times,
	}
}

type MockSimpleBazExpect struct {
	*MockSimpleBazWhen
	validateArgs *func(_a int, _b string) bool
	times *MockSimpleTimes[*MockSimpleBazWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleBazExpect) Expect(_a func(int) bool, _b func(string) bool) *MockSimpleBazWhenWithTimes {
	if !(_a == nil && _b == nil) {
		*_this.validateArgs = func(__a int, __b string) bool {
			return (_a == nil || _a(__a)) && (_b == nil || _b(__b))
		}
	}
	return &MockSimpleBazWhenWithTimes {
		MockSimpleBazWhen: _this.MockSimpleBazWhen,
		MockSimpleTimes: _this.times,
	}
}

type MockSimpleBazExpectWithTimes struct {
	*MockSimpleTimes[*MockSimpleBazWhen]
	*MockSimpleBazExpect
}

type MockSimpleBazWhen struct {
	expected []*struct {
		fun func(_a int, _b string) (_s string)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockSimpleBazWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockSimpleBazWhenWithTimes struct {
	*MockSimpleTimes[*MockSimpleBazWhen]
	*MockSimpleBazWhen
}

// Return the provided values when called
func (_this *MockSimpleBazWhen) Return(_s string) *MockSimpleTimes[*MockSimpleBazWhen] {
	_this.expected[len(_this.expected) -1].fun = func(int, string) (string) { return _s }
	return &MockSimpleTimes[*MockSimpleBazWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleBazWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleBazWhen) Do(do func(_a int, _b string) (_s string)) *MockSimpleTimes[*MockSimpleBazWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockSimpleTimes[*MockSimpleBazWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleBazWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when Fun of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockSimpleWhen) Fun() *MockSimpleFunExpectWithTimes {
	for _, f := range _this.m.vFun {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Fun' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func())
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func()) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) bool
		expected []*struct {
			fun func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func())
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vFun = append(_this.m.vFun, &validator)
	var _then func() *MockSimpleFunWhen
	_then = func() *MockSimpleFunWhen {
		var _newExpected struct {
			fun func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func())
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func()) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockSimpleFunWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockSimpleTimes[*MockSimpleFunWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleFunWhen]{ then: _then, t: _this.m.t},
	}
	return &MockSimpleFunExpectWithTimes {
		MockSimpleFunExpect: &MockSimpleFunExpect {
			MockSimpleFunWhen: &MockSimpleFunWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockSimpleTimes: times,
	}
}

type MockSimpleFunExpect struct {
	*MockSimpleFunWhen
	validateArgs *func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) bool
	times *MockSimpleTimes[*MockSimpleFunWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockSimpleFunExpect) Expect(_a func(func(func(string, string) (int, int), func(string, string) (int, int))) bool, _b func(func(func(string, string) (int, int), func(string, string) (int, int))) bool) *MockSimpleFunWhenWithTimes {
	if !(_a == nil && _b == nil) {
		*_this.validateArgs = func(__a func(func(string, string) (int, int), func(string, string) (int, int)), __b func(func(string, string) (int, int), func(string, string) (int, int))) bool {
			return (_a == nil || _a(__a)) && (_b == nil || _b(__b))
		}
	}
	return &MockSimpleFunWhenWithTimes {
		MockSimpleFunWhen: _this.MockSimpleFunWhen,
		MockSimpleTimes: _this.times,
	}
}

type MockSimpleFunExpectWithTimes struct {
	*MockSimpleTimes[*MockSimpleFunWhen]
	*MockSimpleFunExpect
}

type MockSimpleFunWhen struct {
	expected []*struct {
		fun func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func())
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockSimpleFunWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockSimpleFunWhenWithTimes struct {
	*MockSimpleTimes[*MockSimpleFunWhen]
	*MockSimpleFunWhen
}

// Return the provided values when called
func (_this *MockSimpleFunWhen) Return(_r func(), _r2 func()) *MockSimpleTimes[*MockSimpleFunWhen] {
	_this.expected[len(_this.expected) -1].fun = func(func(func(string, string) (int, int), func(string, string) (int, int)), func(func(string, string) (int, int), func(string, string) (int, int))) (func(), func()) { return _r, _r2 }
	return &MockSimpleTimes[*MockSimpleFunWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleFunWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockSimpleFunWhen) Do(do func(_a func(func(string, string) (int, int), func(string, string) (int, int)), _b func(func(string, string) (int, int), func(string, string) (int, int))) (_r func(), _r2 func())) *MockSimpleTimes[*MockSimpleFunWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockSimpleTimes[*MockSimpleFunWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockSimpleThen: MockSimpleThen[*MockSimpleFunWhen]{ then: _this.then, t: _this.t},
	}
}

type MockSimpleThen [T any] struct {
	then func() T
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

// Then continue with another action
func (_this *MockSimpleThen[T]) Then() T {
	_this.t.Helper()
	return _this.then()
}

type MockSimpleTimes[T any] struct {
	expectedCalled *int
	then func() T
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
	MockSimpleThen[T]
}

// Times sets how often the mocked function is expected to be called.
// Test will fail if the number of calls do not match with the expected calls value.
func (_this *MockSimpleTimes[T]) Times(times int) *MockSimpleThen[T] {
	_this.t.Helper()
	*_this.expectedCalled = times
	retVal := &MockSimpleThen[T] { t: _this.t, then: _this.then }
	if times <= 0 {
		retVal.then = func() T {
			_this.t.Helper()
			callString := "AnyTimes"
			if *_this.expectedCalled == 0 { callString = "Never" }
			_this.t.Fatalf("Then statement is not reachable. Expected calls of previous statement: %s", callString)
			panic("Unreachable!")
		}
	}
	return retVal
}

// AnyTimes disables the check how often a function was called.
func (_this *MockSimpleTimes[T]) AnyTimes() {
	*_this.expectedCalled = -1
}

// Never will fail if the function is ever called.
func (_this *MockSimpleTimes[T]) Never() {
	*_this.expectedCalled = 0
}

