// DO NOT EDIT
// Code generated by smock 

package testpackage_mock

import (
	io "io"
	os "os"
	testpackage "github.com/test/testpackage"
	"fmt"
)

// MockInheritMultiple must implement interface testpackage.InheritMultiple
var _ testpackage.InheritMultiple = &MockInheritMultiple{}

func NewMockInheritMultiple(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockInheritMultiple {
	return &MockInheritMultiple{t: t}
}

type MockInheritMultiple struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	fOwn func(i0 int, i1 string) (r0 int, r1 string)
	fRetType func() (r0 testpackage.MyType)
	fUseStdType func(fi os.FileInfo) (r0 io.Reader)
	fClose func() (r0 error)
	fRead func(p []byte) (n int, err error)
	fSeek func(offset int64, whence int) (r0 int64, r1 error)
}

func (m *MockInheritMultiple) Own(i0 int, i1 string) (r0 int, r1 string) {
	if m.fOwn != nil {
		return m.fOwn(i0, i1)
	} else {
		m.unexpectedCall("Own", fmt.Sprintf("%+v, %+v", i0, i1))
		return
	}
}

func (m *MockInheritMultiple) RetType() (r0 testpackage.MyType) {
	if m.fRetType != nil {
		return m.fRetType()
	} else {
		m.unexpectedCall("RetType", fmt.Sprintf(""))
		return
	}
}

func (m *MockInheritMultiple) UseStdType(fi os.FileInfo) (r0 io.Reader) {
	if m.fUseStdType != nil {
		return m.fUseStdType(fi)
	} else {
		m.unexpectedCall("UseStdType", fmt.Sprintf("%+v", fi))
		return
	}
}

func (m *MockInheritMultiple) Close() (r0 error) {
	if m.fClose != nil {
		return m.fClose()
	} else {
		m.unexpectedCall("Close", fmt.Sprintf(""))
		return
	}
}

func (m *MockInheritMultiple) Read(p []byte) (n int, err error) {
	if m.fRead != nil {
		return m.fRead(p)
	} else {
		m.unexpectedCall("Read", fmt.Sprintf("%+v", p))
		return
	}
}

func (m *MockInheritMultiple) Seek(offset int64, whence int) (r0 int64, r1 error) {
	if m.fSeek != nil {
		return m.fSeek(offset, whence)
	} else {
		m.unexpectedCall("Seek", fmt.Sprintf("%+v, %+v", offset, whence))
		return
	}
}

func (m *MockInheritMultiple) WHEN() *MockInheritMultipleWhen {
	return &MockInheritMultipleWhen{
		m: m,
	}
}

func (m *MockInheritMultiple) unexpectedCall(method, args string) {
	m.t.Helper()
	m.t.Fatalf(`Unexpected call to MockInheritMultiple.%s(%s)`, method, args)
}

type MockInheritMultipleWhen struct {
	m *MockInheritMultiple
}

func (mh *MockInheritMultipleWhen) Own() *MockInheritMultipleOwnFunc {
	mh.m.fOwn = func(i0 int, i1 string) (r0 int, r1 string) { return }
	return &MockInheritMultipleOwnFunc{m: mh.m}
}

type MockInheritMultipleOwnFunc struct {
	m *MockInheritMultiple
}

func (f *MockInheritMultipleOwnFunc) Return(r0 int, r1 string) {
	f.m.fOwn = func(int, string) (int, string) { return r0, r1 }
}

func (f *MockInheritMultipleOwnFunc) Do(do func(i0 int, i1 string) (r0 int, r1 string)) {
	f.m.fOwn = do
}

func (mh *MockInheritMultipleWhen) RetType() *MockInheritMultipleRetTypeFunc {
	mh.m.fRetType = func() (r0 testpackage.MyType) { return }
	return &MockInheritMultipleRetTypeFunc{m: mh.m}
}

type MockInheritMultipleRetTypeFunc struct {
	m *MockInheritMultiple
}

func (f *MockInheritMultipleRetTypeFunc) Return(r0 testpackage.MyType) {
	f.m.fRetType = func() (testpackage.MyType) { return r0 }
}

func (f *MockInheritMultipleRetTypeFunc) Do(do func() (r0 testpackage.MyType)) {
	f.m.fRetType = do
}

func (mh *MockInheritMultipleWhen) UseStdType() *MockInheritMultipleUseStdTypeFunc {
	mh.m.fUseStdType = func(fi os.FileInfo) (r0 io.Reader) { return }
	return &MockInheritMultipleUseStdTypeFunc{m: mh.m}
}

type MockInheritMultipleUseStdTypeFunc struct {
	m *MockInheritMultiple
}

func (f *MockInheritMultipleUseStdTypeFunc) Return(r0 io.Reader) {
	f.m.fUseStdType = func(os.FileInfo) (io.Reader) { return r0 }
}

func (f *MockInheritMultipleUseStdTypeFunc) Do(do func(fi os.FileInfo) (r0 io.Reader)) {
	f.m.fUseStdType = do
}

func (mh *MockInheritMultipleWhen) Close() *MockInheritMultipleCloseFunc {
	mh.m.fClose = func() (r0 error) { return }
	return &MockInheritMultipleCloseFunc{m: mh.m}
}

type MockInheritMultipleCloseFunc struct {
	m *MockInheritMultiple
}

func (f *MockInheritMultipleCloseFunc) Return(r0 error) {
	f.m.fClose = func() (error) { return r0 }
}

func (f *MockInheritMultipleCloseFunc) Do(do func() (r0 error)) {
	f.m.fClose = do
}

func (mh *MockInheritMultipleWhen) Read() *MockInheritMultipleReadFunc {
	mh.m.fRead = func(p []byte) (n int, err error) { return }
	return &MockInheritMultipleReadFunc{m: mh.m}
}

type MockInheritMultipleReadFunc struct {
	m *MockInheritMultiple
}

func (f *MockInheritMultipleReadFunc) Return(n int, err error) {
	f.m.fRead = func([]byte) (int, error) { return n, err }
}

func (f *MockInheritMultipleReadFunc) Do(do func(p []byte) (n int, err error)) {
	f.m.fRead = do
}

func (mh *MockInheritMultipleWhen) Seek() *MockInheritMultipleSeekFunc {
	mh.m.fSeek = func(offset int64, whence int) (r0 int64, r1 error) { return }
	return &MockInheritMultipleSeekFunc{m: mh.m}
}

type MockInheritMultipleSeekFunc struct {
	m *MockInheritMultiple
}

func (f *MockInheritMultipleSeekFunc) Return(r0 int64, r1 error) {
	f.m.fSeek = func(int64, int) (int64, error) { return r0, r1 }
}

func (f *MockInheritMultipleSeekFunc) Do(do func(offset int64, whence int) (r0 int64, r1 error)) {
	f.m.fSeek = do
}
