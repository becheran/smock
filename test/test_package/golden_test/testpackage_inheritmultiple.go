// DO NOT EDIT
// Code generated by smock (unknown)

package testpackage_mock

import (
	fmt "fmt"
	io "io"
	os "os"
	other "github.com/test/testpackage/other"
	reflect "reflect"
	runtime "runtime"
	sync "sync"
	testpackage "github.com/test/testpackage"
)

// NewMockInheritMultiple creates a new mock object which implements the corresponding interface.
// All function calls can be mocked with a custom behavior for tests using the WHEN function on the mock object.
// The mock will use the passed in testing.T to report test failures.
func NewMockInheritMultiple(t interface {
	Fatalf(format string, args ...any)
	Helper()
	Cleanup(f func())
}) *MockInheritMultiple {
	t.Helper()
	m := &MockInheritMultiple{t: t}
	t.Cleanup(func () {
		errStr := ""
		for _, v := range m.vOwn {
			for _, c := range v.expected {
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Own' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
			}
		}
		for _, v := range m.vRead {
			for _, c := range v.expected {
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Read' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
			}
		}
		for _, v := range m.vDo {
			for _, c := range v.expected {
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Do' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
			}
		}
		for _, v := range m.vRetType {
			for _, c := range v.expected {
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'RetType' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
			}
		}
		for _, v := range m.vUseStdType {
			for _, c := range v.expected {
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'UseStdType' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
			}
		}
		for _, v := range m.vClose {
			for _, c := range v.expected {
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Close' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
			}
		}
		for _, v := range m.vSeek {
			for _, c := range v.expected {
				if c.expectedCalled >= 0 && c.expectedCalled != c.called {
					errStr += fmt.Sprintf("\nExpected 'Seek' to be called %d times, but was called %d times. (%s)", c.expectedCalled, c.called, v.location)
				}
			}
		}
		if errStr != "" {
			t.Helper()
			t.Fatalf(errStr)
		}})
	return m
}

type MockInheritMultiple struct {
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
	
	vOwn []*struct{location string; validateArgs func(_i0 int, _i1 string) bool; expected []*struct{fun func(_i0 int, _i1 string) (_r0 int, _r1 string); expectedCalled int; called int; mutex sync.Mutex}}
	vRead []*struct{location string; validateArgs func(_p []byte) bool; expected []*struct{fun func(_p []byte) (_n int, _err error); expectedCalled int; called int; mutex sync.Mutex}}
	vDo []*struct{location string; validateArgs func(_i0 func(other.Custom) other.Custom) bool; expected []*struct{fun func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom); expectedCalled int; called int; mutex sync.Mutex}}
	vRetType []*struct{location string; validateArgs func() bool; expected []*struct{fun func() (_r0 testpackage.MyType); expectedCalled int; called int; mutex sync.Mutex}}
	vUseStdType []*struct{location string; validateArgs func(_fi os.FileInfo) bool; expected []*struct{fun func(_fi os.FileInfo) (_r0 io.Reader); expectedCalled int; called int; mutex sync.Mutex}}
	vClose []*struct{location string; validateArgs func() bool; expected []*struct{fun func() (_r0 error); expectedCalled int; called int; mutex sync.Mutex}}
	vSeek []*struct{location string; validateArgs func(_offset int64, _whence int) bool; expected []*struct{fun func(_offset int64, _whence int) (_r0 int64, _r1 error); expectedCalled int; called int; mutex sync.Mutex}}
}

func (_this *MockInheritMultiple) Own(_i0 int, _i1 string) (_r0 int, _r1 string) {
	for _, _check := range _this.vOwn {
		if _check.validateArgs == nil || _check.validateArgs(_i0, _i1) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_i0, _i1)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Own", _i0, _i1)
	return
}

func (_this *MockInheritMultiple) Read(_p []byte) (_n int, _err error) {
	for _, _check := range _this.vRead {
		if _check.validateArgs == nil || _check.validateArgs(_p) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_p)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Read", _p)
	return
}

func (_this *MockInheritMultiple) Do(_i0 func(other.Custom) other.Custom) (_r0 other.Custom) {
	for _, _check := range _this.vDo {
		if _check.validateArgs == nil || _check.validateArgs(_i0) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_i0)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Do", _i0)
	return
}

func (_this *MockInheritMultiple) RetType() (_r0 testpackage.MyType) {
	for _, _check := range _this.vRetType {
		if _check.validateArgs == nil || _check.validateArgs() {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun()
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("RetType", )
	return
}

func (_this *MockInheritMultiple) UseStdType(_fi os.FileInfo) (_r0 io.Reader) {
	for _, _check := range _this.vUseStdType {
		if _check.validateArgs == nil || _check.validateArgs(_fi) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_fi)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("UseStdType", _fi)
	return
}

func (_this *MockInheritMultiple) Close() (_r0 error) {
	for _, _check := range _this.vClose {
		if _check.validateArgs == nil || _check.validateArgs() {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun()
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Close", )
	return
}

func (_this *MockInheritMultiple) Seek(_offset int64, _whence int) (_r0 int64, _r1 error) {
	for _, _check := range _this.vSeek {
		if _check.validateArgs == nil || _check.validateArgs(_offset, _whence) {
			for _ctr, _exp := range _check.expected {
				_exp.mutex.Lock()
				if _exp.expectedCalled <= 0 || _ctr == len(_check.expected) - 1 || _exp.called < _exp.expectedCalled {
					_exp.called++
					_exp.mutex.Unlock()
					return _exp.fun(_offset, _whence)
				}
				_exp.mutex.Unlock()
			}
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Seek", _offset, _whence)
	return
}

func (_this *MockInheritMultiple) unexpectedCall(method string, args ...any) {
	argsStr := ""
	for idx, arg := range args {
		switch t := reflect.TypeOf(arg); {
		case t.Kind() == reflect.Func:
			argsStr += fmt.Sprintf("%T", t)
		case t.Kind() == reflect.String:
			argsStr += fmt.Sprintf("%q", arg)
		default:
			argsStr += fmt.Sprintf("%+v", arg)
		}
		if idx+1 < len(args) {
			argsStr += ", "
		}
	}
	_this.t.Helper()
	_this.t.Fatalf(`Unexpected call to %s(). If function call is expected add ".WHEN.%s()" to mock.`, method, method)
}

// WHEN is used to set the mock behavior when a specific functions on the object are called.
// Use this to setup your mock for your specific test scenario.
func (_this *MockInheritMultiple) WHEN() *MockInheritMultipleWhen {
	return &MockInheritMultipleWhen {
		m: _this,
	}
}

type MockInheritMultipleWhen struct {
	m *MockInheritMultiple
}

// Defines the behavior when Own of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockInheritMultipleWhen) Own() *MockInheritMultipleOwnExpectWithTimes {
	for _, f := range _this.m.vOwn {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Own' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_i0 int, _i1 string) (_r0 int, _r1 string)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_i0 int, _i1 string) (_r0 int, _r1 string) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_i0 int, _i1 string) bool
		expected []*struct {
			fun func(_i0 int, _i1 string) (_r0 int, _r1 string)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vOwn = append(_this.m.vOwn, &validator)
	var _then func() *MockInheritMultipleOwnWhen
	_then = func() *MockInheritMultipleOwnWhen {
		var _newExpected struct {
			fun func(_i0 int, _i1 string) (_r0 int, _r1 string)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_i0 int, _i1 string) (_r0 int, _r1 string) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockInheritMultipleOwnWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockInheritMultipleTimes[*MockInheritMultipleOwnWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleOwnWhen]{ then: _then, t: _this.m.t},
	}
	return &MockInheritMultipleOwnExpectWithTimes {
		MockInheritMultipleOwnExpect: &MockInheritMultipleOwnExpect {
			MockInheritMultipleOwnWhen: &MockInheritMultipleOwnWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockInheritMultipleTimes: times,
	}
}

type MockInheritMultipleOwnExpect struct {
	*MockInheritMultipleOwnWhen
	validateArgs *func(_i0 int, _i1 string) bool
	times *MockInheritMultipleTimes[*MockInheritMultipleOwnWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockInheritMultipleOwnExpect) Expect(_0 func(int) bool, _1 func(string) bool) *MockInheritMultipleOwnWhenWithTimes {
	if !(_0 == nil && _1 == nil) {
		*_this.validateArgs = func(__i0 int, __i1 string) bool {
			return (_0 == nil || _0(__i0)) && (_1 == nil || _1(__i1))
		}
	}
	return &MockInheritMultipleOwnWhenWithTimes {
		MockInheritMultipleOwnWhen: _this.MockInheritMultipleOwnWhen,
		MockInheritMultipleTimes: _this.times,
	}
}

type MockInheritMultipleOwnExpectWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleOwnWhen]
	*MockInheritMultipleOwnExpect
}

type MockInheritMultipleOwnWhen struct {
	expected []*struct {
		fun func(_i0 int, _i1 string) (_r0 int, _r1 string)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockInheritMultipleOwnWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockInheritMultipleOwnWhenWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleOwnWhen]
	*MockInheritMultipleOwnWhen
}

// Return the provided values when called
func (_this *MockInheritMultipleOwnWhen) Return(_r0 int, _r1 string) *MockInheritMultipleTimes[*MockInheritMultipleOwnWhen] {
	_this.expected[len(_this.expected) -1].fun = func(int, string) (int, string) { return _r0, _r1 }
	return &MockInheritMultipleTimes[*MockInheritMultipleOwnWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleOwnWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockInheritMultipleOwnWhen) Do(do func(_i0 int, _i1 string) (_r0 int, _r1 string)) *MockInheritMultipleTimes[*MockInheritMultipleOwnWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockInheritMultipleTimes[*MockInheritMultipleOwnWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleOwnWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when Read of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockInheritMultipleWhen) Read() *MockInheritMultipleReadExpectWithTimes {
	for _, f := range _this.m.vRead {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Read' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_p []byte) (_n int, _err error)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_p []byte) (_n int, _err error) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_p []byte) bool
		expected []*struct {
			fun func(_p []byte) (_n int, _err error)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vRead = append(_this.m.vRead, &validator)
	var _then func() *MockInheritMultipleReadWhen
	_then = func() *MockInheritMultipleReadWhen {
		var _newExpected struct {
			fun func(_p []byte) (_n int, _err error)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_p []byte) (_n int, _err error) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockInheritMultipleReadWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockInheritMultipleTimes[*MockInheritMultipleReadWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleReadWhen]{ then: _then, t: _this.m.t},
	}
	return &MockInheritMultipleReadExpectWithTimes {
		MockInheritMultipleReadExpect: &MockInheritMultipleReadExpect {
			MockInheritMultipleReadWhen: &MockInheritMultipleReadWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockInheritMultipleTimes: times,
	}
}

type MockInheritMultipleReadExpect struct {
	*MockInheritMultipleReadWhen
	validateArgs *func(_p []byte) bool
	times *MockInheritMultipleTimes[*MockInheritMultipleReadWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockInheritMultipleReadExpect) Expect(_p func([]byte) bool) *MockInheritMultipleReadWhenWithTimes {
	if !(_p == nil) {
		*_this.validateArgs = func(__p []byte) bool {
			return (_p == nil || _p(__p))
		}
	}
	return &MockInheritMultipleReadWhenWithTimes {
		MockInheritMultipleReadWhen: _this.MockInheritMultipleReadWhen,
		MockInheritMultipleTimes: _this.times,
	}
}

type MockInheritMultipleReadExpectWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleReadWhen]
	*MockInheritMultipleReadExpect
}

type MockInheritMultipleReadWhen struct {
	expected []*struct {
		fun func(_p []byte) (_n int, _err error)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockInheritMultipleReadWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockInheritMultipleReadWhenWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleReadWhen]
	*MockInheritMultipleReadWhen
}

// Return the provided values when called
func (_this *MockInheritMultipleReadWhen) Return(_n int, _err error) *MockInheritMultipleTimes[*MockInheritMultipleReadWhen] {
	_this.expected[len(_this.expected) -1].fun = func([]byte) (int, error) { return _n, _err }
	return &MockInheritMultipleTimes[*MockInheritMultipleReadWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleReadWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockInheritMultipleReadWhen) Do(do func(_p []byte) (_n int, _err error)) *MockInheritMultipleTimes[*MockInheritMultipleReadWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockInheritMultipleTimes[*MockInheritMultipleReadWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleReadWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when Do of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockInheritMultipleWhen) Do() *MockInheritMultipleDoExpectWithTimes {
	for _, f := range _this.m.vDo {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Do' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_i0 func(other.Custom) other.Custom) bool
		expected []*struct {
			fun func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vDo = append(_this.m.vDo, &validator)
	var _then func() *MockInheritMultipleDoWhen
	_then = func() *MockInheritMultipleDoWhen {
		var _newExpected struct {
			fun func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockInheritMultipleDoWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockInheritMultipleTimes[*MockInheritMultipleDoWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleDoWhen]{ then: _then, t: _this.m.t},
	}
	return &MockInheritMultipleDoExpectWithTimes {
		MockInheritMultipleDoExpect: &MockInheritMultipleDoExpect {
			MockInheritMultipleDoWhen: &MockInheritMultipleDoWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockInheritMultipleTimes: times,
	}
}

type MockInheritMultipleDoExpect struct {
	*MockInheritMultipleDoWhen
	validateArgs *func(_i0 func(other.Custom) other.Custom) bool
	times *MockInheritMultipleTimes[*MockInheritMultipleDoWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockInheritMultipleDoExpect) Expect(_0 func(func(other.Custom) other.Custom) bool) *MockInheritMultipleDoWhenWithTimes {
	if !(_0 == nil) {
		*_this.validateArgs = func(__i0 func(other.Custom) other.Custom) bool {
			return (_0 == nil || _0(__i0))
		}
	}
	return &MockInheritMultipleDoWhenWithTimes {
		MockInheritMultipleDoWhen: _this.MockInheritMultipleDoWhen,
		MockInheritMultipleTimes: _this.times,
	}
}

type MockInheritMultipleDoExpectWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleDoWhen]
	*MockInheritMultipleDoExpect
}

type MockInheritMultipleDoWhen struct {
	expected []*struct {
		fun func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockInheritMultipleDoWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockInheritMultipleDoWhenWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleDoWhen]
	*MockInheritMultipleDoWhen
}

// Return the provided values when called
func (_this *MockInheritMultipleDoWhen) Return(_r0 other.Custom) *MockInheritMultipleTimes[*MockInheritMultipleDoWhen] {
	_this.expected[len(_this.expected) -1].fun = func(func(other.Custom) other.Custom) (other.Custom) { return _r0 }
	return &MockInheritMultipleTimes[*MockInheritMultipleDoWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleDoWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockInheritMultipleDoWhen) Do(do func(_i0 func(other.Custom) other.Custom) (_r0 other.Custom)) *MockInheritMultipleTimes[*MockInheritMultipleDoWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockInheritMultipleTimes[*MockInheritMultipleDoWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleDoWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when RetType of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockInheritMultipleWhen) RetType() *MockInheritMultipleRetTypeWhenWithTimes {
	for _, f := range _this.m.vRetType {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'RetType' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func() (_r0 testpackage.MyType)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func() (_r0 testpackage.MyType) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func() bool
		expected []*struct {
			fun func() (_r0 testpackage.MyType)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vRetType = append(_this.m.vRetType, &validator)
	var _then func() *MockInheritMultipleRetTypeWhen
	_then = func() *MockInheritMultipleRetTypeWhen {
		var _newExpected struct {
			fun func() (_r0 testpackage.MyType)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func() (_r0 testpackage.MyType) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockInheritMultipleRetTypeWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockInheritMultipleTimes[*MockInheritMultipleRetTypeWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleRetTypeWhen]{ then: _then, t: _this.m.t},
	}
	return &MockInheritMultipleRetTypeWhenWithTimes {
		MockInheritMultipleRetTypeWhen: &MockInheritMultipleRetTypeWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		},
		MockInheritMultipleTimes: times,
	}
}

type MockInheritMultipleRetTypeWhen struct {
	expected []*struct {
		fun func() (_r0 testpackage.MyType)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockInheritMultipleRetTypeWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockInheritMultipleRetTypeWhenWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleRetTypeWhen]
	*MockInheritMultipleRetTypeWhen
}

// Return the provided values when called
func (_this *MockInheritMultipleRetTypeWhen) Return(_r0 testpackage.MyType) *MockInheritMultipleTimes[*MockInheritMultipleRetTypeWhen] {
	_this.expected[len(_this.expected) -1].fun = func() (testpackage.MyType) { return _r0 }
	return &MockInheritMultipleTimes[*MockInheritMultipleRetTypeWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleRetTypeWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockInheritMultipleRetTypeWhen) Do(do func() (_r0 testpackage.MyType)) *MockInheritMultipleTimes[*MockInheritMultipleRetTypeWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockInheritMultipleTimes[*MockInheritMultipleRetTypeWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleRetTypeWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when UseStdType of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockInheritMultipleWhen) UseStdType() *MockInheritMultipleUseStdTypeExpectWithTimes {
	for _, f := range _this.m.vUseStdType {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'UseStdType' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_fi os.FileInfo) (_r0 io.Reader)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_fi os.FileInfo) (_r0 io.Reader) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_fi os.FileInfo) bool
		expected []*struct {
			fun func(_fi os.FileInfo) (_r0 io.Reader)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vUseStdType = append(_this.m.vUseStdType, &validator)
	var _then func() *MockInheritMultipleUseStdTypeWhen
	_then = func() *MockInheritMultipleUseStdTypeWhen {
		var _newExpected struct {
			fun func(_fi os.FileInfo) (_r0 io.Reader)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_fi os.FileInfo) (_r0 io.Reader) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockInheritMultipleUseStdTypeWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleUseStdTypeWhen]{ then: _then, t: _this.m.t},
	}
	return &MockInheritMultipleUseStdTypeExpectWithTimes {
		MockInheritMultipleUseStdTypeExpect: &MockInheritMultipleUseStdTypeExpect {
			MockInheritMultipleUseStdTypeWhen: &MockInheritMultipleUseStdTypeWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockInheritMultipleTimes: times,
	}
}

type MockInheritMultipleUseStdTypeExpect struct {
	*MockInheritMultipleUseStdTypeWhen
	validateArgs *func(_fi os.FileInfo) bool
	times *MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockInheritMultipleUseStdTypeExpect) Expect(_fi func(os.FileInfo) bool) *MockInheritMultipleUseStdTypeWhenWithTimes {
	if !(_fi == nil) {
		*_this.validateArgs = func(__fi os.FileInfo) bool {
			return (_fi == nil || _fi(__fi))
		}
	}
	return &MockInheritMultipleUseStdTypeWhenWithTimes {
		MockInheritMultipleUseStdTypeWhen: _this.MockInheritMultipleUseStdTypeWhen,
		MockInheritMultipleTimes: _this.times,
	}
}

type MockInheritMultipleUseStdTypeExpectWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen]
	*MockInheritMultipleUseStdTypeExpect
}

type MockInheritMultipleUseStdTypeWhen struct {
	expected []*struct {
		fun func(_fi os.FileInfo) (_r0 io.Reader)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockInheritMultipleUseStdTypeWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockInheritMultipleUseStdTypeWhenWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen]
	*MockInheritMultipleUseStdTypeWhen
}

// Return the provided values when called
func (_this *MockInheritMultipleUseStdTypeWhen) Return(_r0 io.Reader) *MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen] {
	_this.expected[len(_this.expected) -1].fun = func(os.FileInfo) (io.Reader) { return _r0 }
	return &MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleUseStdTypeWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockInheritMultipleUseStdTypeWhen) Do(do func(_fi os.FileInfo) (_r0 io.Reader)) *MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockInheritMultipleTimes[*MockInheritMultipleUseStdTypeWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleUseStdTypeWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when Close of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockInheritMultipleWhen) Close() *MockInheritMultipleCloseWhenWithTimes {
	for _, f := range _this.m.vClose {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Close' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func() (_r0 error)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func() (_r0 error) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func() bool
		expected []*struct {
			fun func() (_r0 error)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vClose = append(_this.m.vClose, &validator)
	var _then func() *MockInheritMultipleCloseWhen
	_then = func() *MockInheritMultipleCloseWhen {
		var _newExpected struct {
			fun func() (_r0 error)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func() (_r0 error) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockInheritMultipleCloseWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockInheritMultipleTimes[*MockInheritMultipleCloseWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleCloseWhen]{ then: _then, t: _this.m.t},
	}
	return &MockInheritMultipleCloseWhenWithTimes {
		MockInheritMultipleCloseWhen: &MockInheritMultipleCloseWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		},
		MockInheritMultipleTimes: times,
	}
}

type MockInheritMultipleCloseWhen struct {
	expected []*struct {
		fun func() (_r0 error)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockInheritMultipleCloseWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockInheritMultipleCloseWhenWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleCloseWhen]
	*MockInheritMultipleCloseWhen
}

// Return the provided values when called
func (_this *MockInheritMultipleCloseWhen) Return(_r0 error) *MockInheritMultipleTimes[*MockInheritMultipleCloseWhen] {
	_this.expected[len(_this.expected) -1].fun = func() (error) { return _r0 }
	return &MockInheritMultipleTimes[*MockInheritMultipleCloseWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleCloseWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockInheritMultipleCloseWhen) Do(do func() (_r0 error)) *MockInheritMultipleTimes[*MockInheritMultipleCloseWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockInheritMultipleTimes[*MockInheritMultipleCloseWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleCloseWhen]{ then: _this.then, t: _this.t},
	}
}

// Defines the behavior when Seek of the mock is called.
//
// As a default the method is expected to be called once.
// To change this behavior use the Times() method to define how often the function shall be called.
func (_this *MockInheritMultipleWhen) Seek() *MockInheritMultipleSeekExpectWithTimes {
	for _, f := range _this.m.vSeek {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Seek' is already captured by previous WHEN statement.")
		}
	}
	var defaultExpected struct {
		fun func(_offset int64, _whence int) (_r0 int64, _r1 error)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	defaultExpected.fun = func(_offset int64, _whence int) (_r0 int64, _r1 error) { return }
	defaultExpected.expectedCalled = 1
	
	var validator struct {
		location string
		validateArgs func(_offset int64, _whence int) bool
		expected []*struct {
			fun func(_offset int64, _whence int) (_r0 int64, _r1 error)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
	}
	if _, file, line, ok := runtime.Caller(1); ok {
		validator.location = fmt.Sprintf("%s:%d", file, line)
	}
	validator.expected = append(validator.expected, &defaultExpected)
	_this.m.vSeek = append(_this.m.vSeek, &validator)
	var _then func() *MockInheritMultipleSeekWhen
	_then = func() *MockInheritMultipleSeekWhen {
		var _newExpected struct {
			fun func(_offset int64, _whence int) (_r0 int64, _r1 error)
			expectedCalled int
			called int
			mutex sync.Mutex
		}
		_newExpected.fun = func(_offset int64, _whence int) (_r0 int64, _r1 error) { return }
		_newExpected.expectedCalled = 1
		
		validator.expected = append(validator.expected, &_newExpected)
		return &MockInheritMultipleSeekWhen {
			expected: validator.expected,
			then: _then,
			t: _this.m.t,
		}
	}
	
	times := &MockInheritMultipleTimes[*MockInheritMultipleSeekWhen] {
		expectedCalled: &validator.expected[0].expectedCalled,
		then: _then,
		t: _this.m.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleSeekWhen]{ then: _then, t: _this.m.t},
	}
	return &MockInheritMultipleSeekExpectWithTimes {
		MockInheritMultipleSeekExpect: &MockInheritMultipleSeekExpect {
			MockInheritMultipleSeekWhen: &MockInheritMultipleSeekWhen {
				expected: validator.expected,
				then: _then,
				t: _this.m.t,
			},
			validateArgs: &validator.validateArgs,
			times: times,
		},
		MockInheritMultipleTimes: times,
	}
}

type MockInheritMultipleSeekExpect struct {
	*MockInheritMultipleSeekWhen
	validateArgs *func(_offset int64, _whence int) bool
	times *MockInheritMultipleTimes[*MockInheritMultipleSeekWhen]
}

// Expect will filter for given arguments.
// Each argument is matched with a filter function. Only if all arguments match this mocked function will be called.

// Arguments are either evaluated using the function, or ignored and always true if the function is set to nil.
func (_this *MockInheritMultipleSeekExpect) Expect(_offset func(int64) bool, _whence func(int) bool) *MockInheritMultipleSeekWhenWithTimes {
	if !(_offset == nil && _whence == nil) {
		*_this.validateArgs = func(__offset int64, __whence int) bool {
			return (_offset == nil || _offset(__offset)) && (_whence == nil || _whence(__whence))
		}
	}
	return &MockInheritMultipleSeekWhenWithTimes {
		MockInheritMultipleSeekWhen: _this.MockInheritMultipleSeekWhen,
		MockInheritMultipleTimes: _this.times,
	}
}

type MockInheritMultipleSeekExpectWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleSeekWhen]
	*MockInheritMultipleSeekExpect
}

type MockInheritMultipleSeekWhen struct {
	expected []*struct {
		fun func(_offset int64, _whence int) (_r0 int64, _r1 error)
		expectedCalled int
		called int
		mutex sync.Mutex
	}
	then func() *MockInheritMultipleSeekWhen
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

type MockInheritMultipleSeekWhenWithTimes struct {
	*MockInheritMultipleTimes[*MockInheritMultipleSeekWhen]
	*MockInheritMultipleSeekWhen
}

// Return the provided values when called
func (_this *MockInheritMultipleSeekWhen) Return(_r0 int64, _r1 error) *MockInheritMultipleTimes[*MockInheritMultipleSeekWhen] {
	_this.expected[len(_this.expected) -1].fun = func(int64, int) (int64, error) { return _r0, _r1 }
	return &MockInheritMultipleTimes[*MockInheritMultipleSeekWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleSeekWhen]{ then: _this.then, t: _this.t},
	}
}

// Do will execute the provided function and return the result when called
func (_this *MockInheritMultipleSeekWhen) Do(do func(_offset int64, _whence int) (_r0 int64, _r1 error)) *MockInheritMultipleTimes[*MockInheritMultipleSeekWhen] {
	_this.expected[len(_this.expected) -1].fun = do
	return &MockInheritMultipleTimes[*MockInheritMultipleSeekWhen] {
		expectedCalled: &_this.expected[len(_this.expected) -1].expectedCalled,
		then: _this.then,
		t: _this.t,
		MockInheritMultipleThen: MockInheritMultipleThen[*MockInheritMultipleSeekWhen]{ then: _this.then, t: _this.t},
	}
}

type MockInheritMultipleThen [T any] struct {
	then func() T
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
}

// Then continue with another action
func (_this *MockInheritMultipleThen[T]) Then() T {
	_this.t.Helper()
	return _this.then()
}

type MockInheritMultipleTimes[T any] struct {
	expectedCalled *int
	then func() T
	t interface {
		Fatalf(format string, args ...any)
		Helper()
	}
	MockInheritMultipleThen[T]
}

// Times sets how often the mocked function is expected to be called.
// Test will fail if the number of calls do not match with the expected calls value.
func (_this *MockInheritMultipleTimes[T]) Times(times int) *MockInheritMultipleThen[T] {
	_this.t.Helper()
	*_this.expectedCalled = times
	retVal := &MockInheritMultipleThen[T] { t: _this.t, then: _this.then }
	if times <= 0 {
		retVal.then = func() T {
			_this.t.Helper()
			callString := "AnyTimes"
			if *_this.expectedCalled == 0 { callString = "Never" }
			_this.t.Fatalf("Then statement is not reachable. Expected calls of previous statement: %s", callString)
			panic("Unreachable!")
		}
	}
	return retVal
}

// AnyTimes disables the check how often a function was called.
func (_this *MockInheritMultipleTimes[T]) AnyTimes() {
	*_this.expectedCalled = -1
}

// Never will fail if the function is ever called.
func (_this *MockInheritMultipleTimes[T]) Never() {
	*_this.expectedCalled = 0
}

