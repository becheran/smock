// DO NOT EDIT
// Code generated by smock 

package testpackage_mock

import (
	io "io"
	os "os"
	testpackage "github.com/test/testpackage"
	"fmt"
)

// MockInheritOwn must implement interface testpackage.InheritOwn
var _ testpackage.InheritOwn = &MockInheritOwn{}

func NewMockInheritOwn(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockInheritOwn {
	return &MockInheritOwn{t: t}
}

type MockInheritOwn struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	
	vRetType []*struct{fun func() (r0 testpackage.MyType); validateArgs func() bool}
	vUseStdType []*struct{fun func(fi os.FileInfo) (r0 io.Reader); validateArgs func(fi os.FileInfo) bool}
}

func (m *MockInheritOwn) RetType() (r0 testpackage.MyType) {
	for _, check := range m.vRetType {
		if check.validateArgs == nil || check.validateArgs() {
			return check.fun()
		}
	}
	m.unexpectedCall("RetType", fmt.Sprintf(""))
	return
}

func (m *MockInheritOwn) UseStdType(fi os.FileInfo) (r0 io.Reader) {
	for _, check := range m.vUseStdType {
		if check.validateArgs == nil || check.validateArgs(fi) {
			return check.fun(fi)
		}
	}
	m.unexpectedCall("UseStdType", fmt.Sprintf("%+v", fi))
	return
}

func (m *MockInheritOwn) WHEN() *MockInheritOwnWhen {
	return &MockInheritOwnWhen{
		m: m,
	}
}

func (m *MockInheritOwn) unexpectedCall(method, args string) {
	m.t.Helper()
	m.t.Fatalf(`Unexpected call to MockInheritOwn.%s(%s)`, method, args)
}

type MockInheritOwnWhen struct {
	m *MockInheritOwn
}

func (mh *MockInheritOwnWhen) RetType() *MockInheritOwnRetTypeArgsEval {
	var validator struct {
		fun func() (r0 testpackage.MyType)
		validateArgs func() bool
	}
	validator.fun = func() (r0 testpackage.MyType) { return }
	mh.m.vRetType = append(mh.m.vRetType, &validator)
	return &MockInheritOwnRetTypeArgsEval {
		fun: &validator.fun,
	}
}

type MockInheritOwnRetTypeArgsEval struct {
	fun *func() (r0 testpackage.MyType)
}

func (f *MockInheritOwnRetTypeArgsEval) Return(r0 testpackage.MyType) {
	*f.fun = func() (testpackage.MyType) { return r0 }
}

func (f *MockInheritOwnRetTypeArgsEval) Do(do func() (r0 testpackage.MyType)) {
	*f.fun = do
}

func (mh *MockInheritOwnWhen) UseStdType() *MockInheritOwnUseStdTypeArgs {
	var validator struct {
		fun func(fi os.FileInfo) (r0 io.Reader)
		validateArgs func(fi os.FileInfo) bool
	}
	validator.fun = func(fi os.FileInfo) (r0 io.Reader) { return }
	mh.m.vUseStdType = append(mh.m.vUseStdType, &validator)
	return &MockInheritOwnUseStdTypeArgs {
		MockInheritOwnUseStdTypeArgsEval: MockInheritOwnUseStdTypeArgsEval{fun: &validator.fun},
		validateArgs: &validator.validateArgs,
		fun: &validator.fun,
	}
}

type MockInheritOwnUseStdTypeArgs struct {
	MockInheritOwnUseStdTypeArgsEval
	fun *func(fi os.FileInfo) (r0 io.Reader)
	validateArgs *func(fi os.FileInfo) bool
}

func (f *MockInheritOwnUseStdTypeArgs) ExpectArgs(matchfi interface{Match(os.FileInfo) bool}) *MockInheritOwnUseStdTypeArgsEval {
	*f.validateArgs = func(fi os.FileInfo) bool {
		return (matchfi == nil || matchfi.Match(fi))
	}
	return &f.MockInheritOwnUseStdTypeArgsEval
}

type MockInheritOwnUseStdTypeArgsEval struct {
	fun *func(fi os.FileInfo) (r0 io.Reader)
}

func (f *MockInheritOwnUseStdTypeArgsEval) Return(r0 io.Reader) {
	*f.fun = func(os.FileInfo) (io.Reader) { return r0 }
}

func (f *MockInheritOwnUseStdTypeArgsEval) Do(do func(fi os.FileInfo) (r0 io.Reader)) {
	*f.fun = do
}
