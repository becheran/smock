// DO NOT EDIT
// Code generated by smock 

package testpackage_mock

import (
	"fmt"
	"reflect"
)

func NewMockWithLambda[T comparable](t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockWithLambda[T] {
	return &MockWithLambda[T]{t: t}
}

type MockWithLambda[T comparable] struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	
	vFoo []*struct{fun func(a int, b ...string) (r0 bool); validateArgs func(a int, b ...string) bool}
	vBar []*struct{fun func(b ...struct{}) (r0 bool); validateArgs func(b ...struct{}) bool}
	vBaz []*struct{fun func(b ...T) (r0 bool); validateArgs func(b ...T) bool}
}

func (_this *MockWithLambda[T]) Foo(a int, b ...string) (r0 bool) {
	for _, _check := range _this.vFoo {
		if _check.validateArgs == nil || _check.validateArgs(a, b...) {
			return _check.fun(a, b...)
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Foo", a, b)
	return
}

func (_this *MockWithLambda[T]) Bar(b ...struct{}) (r0 bool) {
	for _, _check := range _this.vBar {
		if _check.validateArgs == nil || _check.validateArgs(b...) {
			return _check.fun(b...)
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Bar", b)
	return
}

func (_this *MockWithLambda[T]) Baz(b ...T) (r0 bool) {
	for _, _check := range _this.vBaz {
		if _check.validateArgs == nil || _check.validateArgs(b...) {
			return _check.fun(b...)
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("Baz", b)
	return
}

func (_this *MockWithLambda[T]) unexpectedCall(method string, args ...any) {
	argsStr := ""
	for idx, arg := range args {
		switch t := reflect.TypeOf(arg); {
		case t.Kind() == reflect.Func:
			argsStr += fmt.Sprintf("%T", t)
		case t.Kind() == reflect.String:
			argsStr += fmt.Sprintf("%q", arg)
		default:
			argsStr += fmt.Sprintf("%+v", arg)
		}
		if idx+1 < len(args) {
			argsStr += ", "
		}
	}
	_this.t.Helper()
	_this.t.Fatalf(`Unexpected call %s(%s)`, method, argsStr)
}

func (_this *MockWithLambda[T]) WHEN() *MockWithLambdaWhen[T] {
	return &MockWithLambdaWhen[T]{
		m: _this,
	}
}

type MockWithLambdaWhen[T comparable] struct {
	m *MockWithLambda[T]
}

func (_this *MockWithLambdaWhen[T]) Foo() *MockWithLambdaFooArgs[T] {
	for _, f := range _this.m.vFoo {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Foo' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(a int, b ...string) (r0 bool)
		validateArgs func(a int, b ...string) bool
	}
	validator.fun = func(a int, b ...string) (r0 bool) { return }
	_this.m.vFoo = append(_this.m.vFoo, &validator)
	return &MockWithLambdaFooArgs[T] {
		MockWithLambdaFooArgsEval: MockWithLambdaFooArgsEval[T]{fun: &validator.fun},
		validateArgs: &validator.validateArgs,
		fun: &validator.fun,
	}
}

type MockWithLambdaFooArgs[T comparable] struct {
	MockWithLambdaFooArgsEval[T]
	fun *func(a int, b ...string) (r0 bool)
	validateArgs *func(a int, b ...string) bool
}

func (_this *MockWithLambdaFooArgs[T]) Expect(a func(int) bool, b ...func(string) bool) *MockWithLambdaFooArgsEval[T] {
	if !(a == nil && len(b) == 0) {
		*_this.validateArgs = func(_a int, _b ...string) bool {
			for _idx, _val := range _b {
				if _idx >= len(b) || !(b[_idx] == nil || b[_idx](_val)) {
					return false
				}
			}
			return (a == nil || a(_a)) && true
		}
	}
	return &_this.MockWithLambdaFooArgsEval
}

type MockWithLambdaFooArgsEval[T comparable] struct {
	fun *func(a int, b ...string) (r0 bool)
}

func (_this *MockWithLambdaFooArgsEval[T]) Return(r0 bool) {
	*_this.fun = func(int, ...string) (bool) { return r0 }
}

func (_this *MockWithLambdaFooArgsEval[T]) Do(do func(a int, b ...string) (r0 bool)) {
	*_this.fun = do
}

func (_this *MockWithLambdaWhen[T]) Bar() *MockWithLambdaBarArgs[T] {
	for _, f := range _this.m.vBar {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Bar' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(b ...struct{}) (r0 bool)
		validateArgs func(b ...struct{}) bool
	}
	validator.fun = func(b ...struct{}) (r0 bool) { return }
	_this.m.vBar = append(_this.m.vBar, &validator)
	return &MockWithLambdaBarArgs[T] {
		MockWithLambdaBarArgsEval: MockWithLambdaBarArgsEval[T]{fun: &validator.fun},
		validateArgs: &validator.validateArgs,
		fun: &validator.fun,
	}
}

type MockWithLambdaBarArgs[T comparable] struct {
	MockWithLambdaBarArgsEval[T]
	fun *func(b ...struct{}) (r0 bool)
	validateArgs *func(b ...struct{}) bool
}

func (_this *MockWithLambdaBarArgs[T]) Expect(b ...func(struct{}) bool) *MockWithLambdaBarArgsEval[T] {
	if !(len(b) == 0) {
		*_this.validateArgs = func(_b ...struct{}) bool {
			for _idx, _val := range _b {
				if _idx >= len(b) || !(b[_idx] == nil || b[_idx](_val)) {
					return false
				}
			}
			return true
		}
	}
	return &_this.MockWithLambdaBarArgsEval
}

type MockWithLambdaBarArgsEval[T comparable] struct {
	fun *func(b ...struct{}) (r0 bool)
}

func (_this *MockWithLambdaBarArgsEval[T]) Return(r0 bool) {
	*_this.fun = func(...struct{}) (bool) { return r0 }
}

func (_this *MockWithLambdaBarArgsEval[T]) Do(do func(b ...struct{}) (r0 bool)) {
	*_this.fun = do
}

func (_this *MockWithLambdaWhen[T]) Baz() *MockWithLambdaBazArgs[T] {
	for _, f := range _this.m.vBaz {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'Baz' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(b ...T) (r0 bool)
		validateArgs func(b ...T) bool
	}
	validator.fun = func(b ...T) (r0 bool) { return }
	_this.m.vBaz = append(_this.m.vBaz, &validator)
	return &MockWithLambdaBazArgs[T] {
		MockWithLambdaBazArgsEval: MockWithLambdaBazArgsEval[T]{fun: &validator.fun},
		validateArgs: &validator.validateArgs,
		fun: &validator.fun,
	}
}

type MockWithLambdaBazArgs[T comparable] struct {
	MockWithLambdaBazArgsEval[T]
	fun *func(b ...T) (r0 bool)
	validateArgs *func(b ...T) bool
}

func (_this *MockWithLambdaBazArgs[T]) Expect(b ...func(T) bool) *MockWithLambdaBazArgsEval[T] {
	if !(len(b) == 0) {
		*_this.validateArgs = func(_b ...T) bool {
			for _idx, _val := range _b {
				if _idx >= len(b) || !(b[_idx] == nil || b[_idx](_val)) {
					return false
				}
			}
			return true
		}
	}
	return &_this.MockWithLambdaBazArgsEval
}

type MockWithLambdaBazArgsEval[T comparable] struct {
	fun *func(b ...T) (r0 bool)
}

func (_this *MockWithLambdaBazArgsEval[T]) Return(r0 bool) {
	*_this.fun = func(...T) (bool) { return r0 }
}

func (_this *MockWithLambdaBazArgsEval[T]) Do(do func(b ...T) (r0 bool)) {
	*_this.fun = do
}
