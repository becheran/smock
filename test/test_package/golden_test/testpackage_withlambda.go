// DO NOT EDIT
// Code generated by smock 

package testpackage_mock

import (
	testpackage "github.com/test/testpackage"
	"fmt"
)

// MockWithLambda must implement interface testpackage.WithLambda
var _ testpackage.WithLambda = &MockWithLambda{}

func NewMockWithLambda(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockWithLambda {
	return &MockWithLambda{t: t}
}

type MockWithLambda struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	
	vFoo []*struct{fun func(a int, b ...string); validateArgs func(a int, b ...string) bool}
	vEmpty []*struct{fun func(); validateArgs func() bool}
}

func (m *MockWithLambda) Foo(a int, b ...string) {
	for _, check := range m.vFoo {
		if check.validateArgs == nil || check.validateArgs(a, b...) {
			check.fun(a, b...)
			return
		}
	}
	m.unexpectedCall("Foo", fmt.Sprintf("%+v, %+v", a, b))
	return
}

func (m *MockWithLambda) Empty() {
	for _, check := range m.vEmpty {
		if check.validateArgs == nil || check.validateArgs() {
			check.fun()
			return
		}
	}
	m.unexpectedCall("Empty", fmt.Sprintf(""))
	return
}

func (m *MockWithLambda) WHEN() *MockWithLambdaWhen {
	return &MockWithLambdaWhen{
		m: m,
	}
}

func (m *MockWithLambda) unexpectedCall(method, args string) {
	m.t.Helper()
	m.t.Fatalf(`Unexpected call to MockWithLambda.%s(%s)`, method, args)
}

type MockWithLambdaWhen struct {
	m *MockWithLambda
}

func (mh *MockWithLambdaWhen) Foo() *MockWithLambdaFooArgs {
	var validator struct {
		fun func(a int, b ...string)
		validateArgs func(a int, b ...string) bool
	}
	validator.fun = func(a int, b ...string) { return }
	mh.m.vFoo = append(mh.m.vFoo, &validator)
	return &MockWithLambdaFooArgs {
		MockWithLambdaFooArgsEval: MockWithLambdaFooArgsEval{fun: &validator.fun},
		validateArgs: &validator.validateArgs,
		fun: &validator.fun,
	}
}

type MockWithLambdaFooArgs struct {
	MockWithLambdaFooArgsEval
	fun *func(a int, b ...string)
	validateArgs *func(a int, b ...string) bool
}

func (f *MockWithLambdaFooArgs) ExpectArgs(matcha interface{Match(int) bool}, matchb interface{Match(...string) bool}) *MockWithLambdaFooArgsEval {
	*f.validateArgs = func(a int, b ...string) bool {
		return (matcha == nil || matcha.Match(a)) && (matchb == nil || matchb.Match(b...))
	}
	return &f.MockWithLambdaFooArgsEval
}

type MockWithLambdaFooArgsEval struct {
	fun *func(a int, b ...string)
}

func (f *MockWithLambdaFooArgsEval) Do(do func(a int, b ...string)) {
	*f.fun = do
}

func (mh *MockWithLambdaWhen) Empty() *MockWithLambdaEmptyArgsEval {
	var validator struct {
		fun func()
		validateArgs func() bool
	}
	validator.fun = func() { return }
	mh.m.vEmpty = append(mh.m.vEmpty, &validator)
	return &MockWithLambdaEmptyArgsEval {
		fun: &validator.fun,
	}
}

type MockWithLambdaEmptyArgsEval struct {
	fun *func()
}

func (f *MockWithLambdaEmptyArgsEval) Do(do func()) {
	*f.fun = do
}
