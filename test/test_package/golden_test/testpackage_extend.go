// DO NOT EDIT
// Code generated by smock 

package testpackage_mock

import (
	io "io"
	os "os"
	testpackage "github.com/test/testpackage"
	"fmt"
	"reflect"
)

// MockExtend must implement interface testpackage.Extend
var _ testpackage.Extend = &MockExtend{}

func NewMockExtend(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockExtend {
	return &MockExtend{t: t}
}

type MockExtend struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	
	vRetType []*struct{fun func() (r0 testpackage.MyType); validateArgs func() bool}
	vUseStdType []*struct{fun func(fi os.FileInfo) (r0 io.Reader); validateArgs func(fi os.FileInfo) bool}
}

func (_this *MockExtend) RetType() (r0 testpackage.MyType) {
	for _, _check := range _this.vRetType {
		if _check.validateArgs == nil || _check.validateArgs() {
			return _check.fun()
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("RetType", )
	return
}

func (_this *MockExtend) UseStdType(fi os.FileInfo) (r0 io.Reader) {
	for _, _check := range _this.vUseStdType {
		if _check.validateArgs == nil || _check.validateArgs(fi) {
			return _check.fun(fi)
		}
	}
	_this.t.Helper()
	_this.unexpectedCall("UseStdType", fi)
	return
}

func (_this *MockExtend) unexpectedCall(method string, args ...any) {
	argsStr := ""
	for idx, arg := range args {
		switch t := reflect.TypeOf(arg); {
		case t.Kind() == reflect.Func:
			argsStr += fmt.Sprintf("%T", t)
		case t.Kind() == reflect.String:
			argsStr += fmt.Sprintf("%q", arg)
		default:
			argsStr += fmt.Sprintf("%+v", arg)
		}
		if idx+1 < len(args) {
			argsStr += ", "
		}
	}
	_this.t.Helper()
	_this.t.Fatalf(`Unexpected call %s(%s)`, method, argsStr)
}

func (_this *MockExtend) WHEN() *MockExtendWhen {
	return &MockExtendWhen{
		m: _this,
	}
}

type MockExtendWhen struct {
	m *MockExtend
}

func (_this *MockExtendWhen) RetType() *MockExtendRetTypeArgsEval {
	for _, f := range _this.m.vRetType {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'RetType' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func() (r0 testpackage.MyType)
		validateArgs func() bool
	}
	validator.fun = func() (r0 testpackage.MyType) { return }
	_this.m.vRetType = append(_this.m.vRetType, &validator)
	return &MockExtendRetTypeArgsEval {
		fun: &validator.fun,
	}
}

type MockExtendRetTypeArgsEval struct {
	fun *func() (r0 testpackage.MyType)
}

func (_this *MockExtendRetTypeArgsEval) Return(r0 testpackage.MyType) {
	*_this.fun = func() (testpackage.MyType) { return r0 }
}

func (_this *MockExtendRetTypeArgsEval) Do(do func() (r0 testpackage.MyType)) {
	*_this.fun = do
}

func (_this *MockExtendWhen) UseStdType() *MockExtendUseStdTypeArgs {
	for _, f := range _this.m.vUseStdType {
		if f.validateArgs == nil {
			_this.m.t.Helper()
			_this.m.t.Fatalf("Unreachable condition. Call to 'UseStdType' is already captured by previous WHEN statement.")
		}
	}
	var validator struct {
		fun func(fi os.FileInfo) (r0 io.Reader)
		validateArgs func(fi os.FileInfo) bool
	}
	validator.fun = func(fi os.FileInfo) (r0 io.Reader) { return }
	_this.m.vUseStdType = append(_this.m.vUseStdType, &validator)
	return &MockExtendUseStdTypeArgs {
		MockExtendUseStdTypeArgsEval: MockExtendUseStdTypeArgsEval{fun: &validator.fun},
		validateArgs: &validator.validateArgs,
		fun: &validator.fun,
	}
}

type MockExtendUseStdTypeArgs struct {
	MockExtendUseStdTypeArgsEval
	fun *func(fi os.FileInfo) (r0 io.Reader)
	validateArgs *func(fi os.FileInfo) bool
}

func (_this *MockExtendUseStdTypeArgs) Expect(fi func(os.FileInfo) bool) *MockExtendUseStdTypeArgsEval {
	if !(fi == nil) {
		*_this.validateArgs = func(_fi os.FileInfo) bool {
			return (fi == nil || fi(_fi))
		}
	}
	return &_this.MockExtendUseStdTypeArgsEval
}

type MockExtendUseStdTypeArgsEval struct {
	fun *func(fi os.FileInfo) (r0 io.Reader)
}

func (_this *MockExtendUseStdTypeArgsEval) Return(r0 io.Reader) {
	*_this.fun = func(os.FileInfo) (io.Reader) { return r0 }
}

func (_this *MockExtendUseStdTypeArgsEval) Do(do func(fi os.FileInfo) (r0 io.Reader)) {
	*_this.fun = do
}
