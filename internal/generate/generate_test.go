package generate_test

import (
	"testing"

	"github.com/becheran/smock/internal/generate"
	"github.com/becheran/smock/internal/model"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const expOutputWithoutTypes = `// DO NOT EDIT
// Code generated by smock 

package orig_mock

import (
	orig "github.com/becheran/smock/orig"
	fmt "fmt"
)

// MockHandler must implement interface orig.Handler
var _ orig.Handler = &MockHandler{}

func NewMockHandler(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockHandler {
	return &MockHandler{t: t}
}

type MockHandler struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	
	fTarget func() (r0 int)
	fVoid func()
}

func (m *MockHandler) Target() (r0 int) {
	if m.fTarget != nil {
		return m.fTarget()
	} else {
		m.unexpectedCall("Target", fmt.Sprintf(""))
		return
	}
}

func (m *MockHandler) Void() {
	if m.fVoid != nil {
		m.fVoid()
	} else {
		m.unexpectedCall("Void", fmt.Sprintf(""))
		return
	}
}

func (m *MockHandler) WHEN() *MockHandlerWhen {
	return &MockHandlerWhen{
		m: m,
	}
}

func (m *MockHandler) unexpectedCall(method, args string) {
	m.t.Helper()
	m.t.Fatalf(` + "`" + `Unexpected call to MockHandler.%s(%s)` + "`" + `, method, args)
}

type MockHandlerWhen struct {
	m *MockHandler
}

func (mh *MockHandlerWhen) Target() *MockHandlerTargetFunc {
	mh.m.fTarget = func() (r0 int) { return }
	return &MockHandlerTargetFunc{m: mh.m}
}

type MockHandlerTargetFunc struct {
	m *MockHandler
}

func (f *MockHandlerTargetFunc) Return(r0 int) {
	f.m.fTarget = func() (int) { return r0 }
}

func (f *MockHandlerTargetFunc) Do(do func() (r0 int)) {
	f.m.fTarget = do
}

func (mh *MockHandlerWhen) Void() *MockHandlerVoidFunc {
	mh.m.fVoid = func() { return }
	return &MockHandlerVoidFunc{m: mh.m}
}

type MockHandlerVoidFunc struct {
	m *MockHandler
}

func (f *MockHandlerVoidFunc) Do(do func()) {
	f.m.fVoid = do
}
`

func TestGenerateMock(t *testing.T) {
	input := model.InterfaceResult{
		PackageName: "orig",
		Name:        "Handler",
		Imports:     []model.Import{{Name: "orig", Path: "github.com/becheran/smock/orig"}, {Path: "fmt"}},
		Methods: []model.Method{
			{Name: "Target", Results: []model.Ident{{Type: "int"}}},
			{Name: "Void"},
		},
	}

	res, err := generate.GenerateMock(input)

	require.Nil(t, err)
	assert.Equal(t, expOutputWithoutTypes, string(res))
}

const expOutputWithTypes = `// DO NOT EDIT
// Code generated by smock 

package orig_mock

import (
	"fmt"
)

func NewMockHandler[T any, N orig.Number](t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockHandler[T, N] {
	return &MockHandler[T, N]{t: t}
}

type MockHandler[T any, N orig.Number] struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	
	fTarget func(i0 T) (r0 int, r1 N)
}

func (m *MockHandler[T, N]) Target(i0 T) (r0 int, r1 N) {
	if m.fTarget != nil {
		return m.fTarget(i0)
	} else {
		m.unexpectedCall("Target", fmt.Sprintf("%+v", i0))
		return
	}
}

func (m *MockHandler[T, N]) WHEN() *MockHandlerWhen[T, N] {
	return &MockHandlerWhen[T, N]{
		m: m,
	}
}

func (m *MockHandler[T, N]) unexpectedCall(method, args string) {
	m.t.Helper()
	m.t.Fatalf(` + "`" + `Unexpected call to MockHandler.%s(%s)` + "`" + `, method, args)
}

type MockHandlerWhen[T any, N orig.Number] struct {
	m *MockHandler[T, N]
}

func (mh *MockHandlerWhen[T, N]) Target() *MockHandlerTargetFunc[T, N] {
	mh.m.fTarget = func(i0 T) (r0 int, r1 N) { return }
	return &MockHandlerTargetFunc[T, N]{m: mh.m}
}

type MockHandlerTargetFunc[T any, N orig.Number] struct {
	m *MockHandler[T, N]
}

func (f *MockHandlerTargetFunc[T, N]) Return(r0 int, r1 N) {
	f.m.fTarget = func(T) (int, N) { return r0, r1 }
}

func (f *MockHandlerTargetFunc[T, N]) Do(do func(i0 T) (r0 int, r1 N)) {
	f.m.fTarget = do
}
`

func TestGenerateMockWithTypes(t *testing.T) {
	input := model.InterfaceResult{
		PackageName: "orig",
		Name:        "Handler",
		Imports:     []model.Import{{Name: "orig", Path: "github.com/becheran/smock/foo/mock"}},
		Methods: []model.Method{{
			Name:    "Target",
			Params:  []model.Ident{{Type: "T"}},
			Results: []model.Ident{{Type: "int"}, {Type: "N"}}}},
		Types: []model.Ident{{Name: "T", Type: "any"}, {Name: "N", Type: "orig.Number"}},
	}

	res, err := generate.GenerateMock(input)

	require.Nil(t, err)
	assert.Equal(t, expOutputWithTypes, string(res))
}
