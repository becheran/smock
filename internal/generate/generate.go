package generate

import (
	"fmt"
	"runtime/debug"
	"strings"

	"github.com/becheran/smock/internal/logger"
	"github.com/becheran/smock/internal/model"
)

func GenerateMock(res model.InterfaceResult) (mock []byte, err error) {
	logger.Printf("Start generating mock")

	if err := res.ValidateReadyForGenerate(); err != nil {
		return nil, err
	}

	hasTypes := len(res.Types) > 0

	mockedStructName := fmt.Sprintf("%s%s", model.MockPrefix, res.Name)
	mockedStructWithTypeIdentifier := fmt.Sprintf("%s%s", mockedStructName, res.Types.ListIdentifier())
	whenStructName := mockedStructName + "When"
	whenStructNameWithTypeIdentifier := fmt.Sprintf("%s%s", whenStructName, res.Types.ListIdentifier())
	w := newWriter()

	version := "unknown"
	if info, found := debug.ReadBuildInfo(); found {
		version = info.Main.Version
	}
	w.P("// DO NOT EDIT")
	w.P("// Code generated by smock %s", version)
	w.P("")

	w.P("package %s%s", res.PackageName, model.MockPackageSuffix)
	w.P("")

	w.P("import (")
	w.Ident()
	fmtAlreadyImported := false
	reflectAlreadyImported := false
	for _, i := range res.Imports {
		if hasTypes && i.ImportName() == res.PackageName {
			continue
		}
		if i.ImportName() == "fmt" {
			fmtAlreadyImported = true
		}
		if i.ImportName() == "reflect" {
			reflectAlreadyImported = true
		}
		w.P("%s", i)
	}
	if !fmtAlreadyImported {
		w.P(`"fmt"`)
	}
	if !reflectAlreadyImported {
		w.P(`"reflect"`)
	}
	w.EndIdent()
	w.P(")")
	w.P("")

	// Do not validate when generics are used.
	// It is complicated to retrieve a valid type and assert that one concrete type implements the interface.
	if !hasTypes {
		w.P("// %s must implement interface %s.%s", mockedStructName, res.PackageName, res.Name)
		w.P("var _ %s.%s = &%s{}", res.PackageName, res.Name, mockedStructName)
		w.P("")
	}

	w.P(`func New%s%s(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *%s {`,
		mockedStructName, res.Types.ListTypesWithIdentifiers(), mockedStructWithTypeIdentifier)
	w.Ident()
	w.P("return &%s%s{t: t}", mockedStructName, res.Types.ListIdentifier())
	w.EndIdent()
	w.P("}")
	w.P("")

	w.P("type %s%s struct {", mockedStructName, res.Types.ListTypesWithIdentifiers())
	w.Ident()

	w.P(`t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}`)
	w.P("")

	for _, m := range res.Methods {
		w.P("v%s []*struct{fun func%s; validateArgs func(%s) bool}", m.Name, m.Signature(), m.Params.IdentWithTypeString(model.IdentTypeInput))
	}
	w.EndIdent()
	w.P("}")
	w.P("")

	for _, f := range res.Methods {
		w.P("func (_this *%s) %s%s {", mockedStructWithTypeIdentifier, f.Name, f.Signature())
		w.Ident()
		w.P("for _, _check := range _this.v%s {", f.Name)
		w.Ident()
		w.P("if _check.validateArgs == nil || _check.validateArgs(%s) {", f.Params.IdentString(model.IdentTypeInput, true))
		w.Ident()
		if len(f.Results) > 0 {
			w.P("return _check.fun(%s)", f.Params.IdentString(model.IdentTypeInput, true))
		} else {
			w.P("_check.fun(%s)", f.Params.IdentString(model.IdentTypeInput, true))
			w.P("return")
		}
		w.EndIdent()
		w.P("}")
		w.EndIdent()
		w.P("}")
		w.P("_this.t.Helper()")
		w.P(`_this.unexpectedCall("%s", %s)`, f.Name, f.Params.IdentString(model.IdentTypeInput, false))
		if len(f.Results) > 0 {
			w.P(`return`)
		}
		w.EndIdent()
		w.P("}")
		w.P("")
	}

	w.P("func (_this *%s) unexpectedCall(method string, args ...any) {", mockedStructWithTypeIdentifier)
	w.Ident()
	w.P("argsStr := \"\"")
	w.P("for idx, arg := range args {")
	w.Ident()
	w.P("switch t := reflect.TypeOf(arg); {")
	w.P("case t.Kind() == reflect.Func:")
	w.Ident()
	w.P("argsStr += fmt.Sprintf(\"%%T\", t)")
	w.EndIdent()
	w.P("case t.Kind() == reflect.String:")
	w.Ident()
	w.P("argsStr += fmt.Sprintf(\"%%q\", arg)")
	w.EndIdent()
	w.P("default:")
	w.Ident()
	w.P("argsStr += fmt.Sprintf(\"%%+v\", arg)")
	w.EndIdent()
	w.P("}")
	w.P("if idx+1 < len(args) {")
	w.Ident()
	w.P("argsStr += \", \"")
	w.EndIdent()
	w.P("}")
	w.EndIdent()
	w.P("}")
	w.P("_this.t.Helper()")
	w.P("_this.t.Fatalf(`Unexpected call %%s(%%s)`, method, argsStr)")
	w.EndIdent()
	w.P("}")
	w.P("")

	w.P("func (_this *%s) WHEN() *%s {", mockedStructWithTypeIdentifier, whenStructNameWithTypeIdentifier)
	w.Ident()
	w.P("return &%s{", whenStructNameWithTypeIdentifier)
	w.Ident()
	w.P("m: _this,")
	w.EndIdent()
	w.P("}")
	w.EndIdent()
	w.P("}")
	w.P("")

	w.P("type %s%s struct {", whenStructName, res.Types.ListTypesWithIdentifiers())
	w.Ident()
	w.P("m *%s", mockedStructWithTypeIdentifier)
	w.EndIdent()
	w.P("}")
	w.P("")

	for idx, f := range res.Methods {
		whenArgsStruct := fmt.Sprintf("%s%sArgs", mockedStructName, f.Name)
		whenArgsStructRef := fmt.Sprintf("%s%s", whenArgsStruct, res.Types.ListIdentifier())
		whenNoArgsStruct := fmt.Sprintf("%sEval", whenArgsStruct)
		whenNoArgsStructRef := fmt.Sprintf("%s%s", whenNoArgsStruct, res.Types.ListIdentifier())

		hasParams := len(f.Params) > 0
		hasReturnValues := len(f.Results) > 0

		ref := whenNoArgsStructRef
		if hasParams {
			ref = whenArgsStructRef
		}
		w.P("func (_this *%s) %s() *%s {", whenStructNameWithTypeIdentifier, f.Name, ref)
		w.Ident()

		w.P("for _, f := range _this.m.v%s {", f.Name)
		w.Ident()
		w.P("if f.validateArgs == nil {")
		w.Ident()
		w.P("_this.m.t.Helper()")
		w.P("_this.m.t.Fatalf(\"Unreachable condition. Call to '%s' is already captured by previous WHEN statement.\")", f.Name)
		w.EndIdent()
		w.P("}")
		w.EndIdent()
		w.P("}")

		w.P("var validator struct {")
		w.Ident()
		w.P("fun func%s", f.Signature())
		w.P("validateArgs func(%s) bool", f.Params.IdentWithTypeString(model.IdentTypeInput))
		w.EndIdent()
		w.P("}")
		ret := ""
		if hasReturnValues {
			ret = "return "
		}
		w.P("validator.fun = func%s { %s}", f.Signature(), ret)
		w.P("_this.m.v%s = append(_this.m.v%s, &validator)", f.Name, f.Name)
		if hasParams {
			w.P("return &%s {", whenArgsStructRef)
			w.Ident()
			w.P("%s: %s{fun: &validator.fun},", whenNoArgsStruct, whenNoArgsStructRef)
			w.P("validateArgs: &validator.validateArgs,")
		} else {
			w.P("return &%s {", whenNoArgsStructRef)
			w.Ident()
		}
		w.P("fun: &validator.fun,")
		w.EndIdent()
		w.P("}")
		w.EndIdent()
		w.P("}")
		w.P("")

		if hasParams {
			w.P("type %s%s struct {", whenArgsStruct, res.Types.ListTypesWithIdentifiers())
			w.Ident()
			w.P("%s", whenNoArgsStructRef)
			w.P("fun *func%s", f.Signature())
			w.P("validateArgs *func(%s) bool", f.Params.IdentWithTypeString(model.IdentTypeInput))
			w.EndIdent()
			w.P("}")
			w.P("")

			args := ""
			lambdaFieldName := ""
			for idx, arg := range f.Params {
				name := arg.Name
				typeStr := arg.Type
				lambdaPref := ""
				if strings.HasPrefix(arg.Type, "...") {
					lambdaFieldName = name
					typeStr = strings.TrimPrefix(typeStr, "...")
					lambdaPref = "..."
				}
				if name == "" {
					name = fmt.Sprintf("_%d", idx)
				}
				args += fmt.Sprintf("%s %sfunc(%s) bool", name, lambdaPref, typeStr)
				if idx+1 < len(f.Params) {
					args += ", "
				}
			}
			w.P("func (_this *%s) Expect(%s) *%s {", whenArgsStructRef, args, whenNoArgsStructRef)
			w.Ident()
			matchString := ""
			checkAllNil := ""
			for idx, arg := range f.Params {
				if strings.HasPrefix(arg.Type, "...") {
					checkAllNil += fmt.Sprintf("len(%s) == 0", lambdaFieldName)
					matchString += "true"
					break
				}
				name := arg.Name
				input := arg.Name
				if name == "" {
					name = fmt.Sprintf("_%d", idx)
					input = fmt.Sprintf("i%d", idx)
				}
				if strings.HasPrefix(arg.Type, "...") {
					input += "..."
				}
				matchString += fmt.Sprintf("(%s == nil || %s(_%s))", name, name, input)
				checkAllNil += fmt.Sprintf("%s == nil", name)
				if idx+1 < len(f.Params) {
					matchString += " && "
					checkAllNil += " && "
				}
			}
			w.P("if !(%s) {", checkAllNil)
			w.Ident()
			w.P("*_this.validateArgs = func(%s) bool {", f.Params.IdentWithTypeStringAndPrefix(model.IdentTypeInput, "_"))
			w.Ident()
			if lambdaFieldName != "" {
				w.P("for _idx, _val := range _%s {", lambdaFieldName)
				w.Ident()
				w.P("if _idx >= len(%s) || !(%s[_idx] == nil || %s[_idx](_val)) {", lambdaFieldName, lambdaFieldName, lambdaFieldName)
				w.Ident()
				w.P("return false")
				w.EndIdent()
				w.P("}")
				w.EndIdent()
				w.P("}")
			}
			w.P("return %s", matchString)
			w.EndIdent()
			w.P("}")
			w.EndIdent()
			w.P("}")
			w.P("return &_this.%s", whenNoArgsStruct)
			w.EndIdent()
			w.P("}")
			w.P("")
		}

		w.P("type %s%s struct {", whenNoArgsStruct, res.Types.ListTypesWithIdentifiers())
		w.Ident()
		w.P("fun *func%s", f.Signature())
		w.EndIdent()
		w.P("}")
		w.P("")

		if hasReturnValues {
			w.P("func (_this *%s) Return(%s) {", whenNoArgsStructRef, f.Results.IdentWithTypeString(model.IdentTypeResult))
			w.Ident()
			w.P("*_this.fun = func%s { return %s }", f.SignatureWithoutIdentifier(), f.Results.IdentString(model.IdentTypeResult, false))
			w.EndIdent()
			w.P("}")
			w.P("")
		}

		w.P("func (_this *%s) Do(do func%s) {", whenNoArgsStructRef, f.Signature())
		w.Ident()
		w.P("*_this.fun = do")
		w.EndIdent()
		w.P("}")
		if idx < len(res.Methods)-1 {
			w.P("")
		}
	}
	logger.Printf("Finished generating mock")

	return w.buff.Bytes(), nil
}
