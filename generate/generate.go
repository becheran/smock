package generate

import (
	"fmt"
	"runtime/debug"

	"github.com/becheran/smock/logger"
	"github.com/becheran/smock/model"
)

func GenerateMock(res model.InterfaceResult) (mock string, err error) {
	logger.Printf("Start generating mock")
	if err := res.ValidateReadyForGenerate(); err != nil {
		return "", err
	}

	mockedStructName := fmt.Sprintf("%s%s", model.MockPrefix, res.Name)
	expectStructName := mockedStructName + "Expect"

	w := newWriter()

	version := "unkown"
	if info, found := debug.ReadBuildInfo(); found {
		version = info.Main.Version
	}
	w.P("// DO NOT EDIT")
	w.P("// Code generated by smock %s", version)
	w.P("")

	w.P("package %s%s", res.PackageName, model.MockPackageSuffix)
	w.P("")

	w.P("import (")
	w.Ident()
	for _, i := range res.Imports {
		w.P("%s", i)
	}
	w.EndIdent()
	w.P(")")
	w.P("")

	w.P("// %s must implement interface %s.%s", mockedStructName, res.PackageName, res.Name)
	w.P("var _ %s.%s = &%s{}", res.PackageName, res.Name, mockedStructName)
	w.P("")

	w.P(`func New%s(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *%s {`, mockedStructName, mockedStructName)
	w.Ident()
	w.P("return &%s{t: t}", mockedStructName)
	w.EndIdent()
	w.P("}")
	w.P("")

	w.P("type %s struct {", mockedStructName)
	w.Ident()
	w.P(`t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}`)
	for _, m := range res.Methods {
		w.P("f%s func%s", m.Name, m.Signature())
	}
	w.EndIdent()
	w.P("}")
	w.P("")

	for _, f := range res.Methods {
		w.P("func (m *%s) %s%s {", mockedStructName, f.Name, f.Signature())
		w.Ident()
		w.P("if m.f%s != nil {", f.Name)
		w.Ident()
		retStm := ""
		if len(f.Results) > 0 {
			retStm = "return "
		}
		w.P("%sm.f%s(%s)", retStm, f.Name, f.Params.IdentString(model.IdentTypeInput))
		w.EndIdent()
		w.P("} else {")
		w.Ident()
		w.P(`m.unexpectedCall("%s", "%s")`, f.Name, f.Params.IdentWithTypeString(model.IdentTypeInput))
		w.P(`return`)
		w.EndIdent()
		w.P("}")
		w.EndIdent()
		w.P("}")
		w.P("")
	}

	w.P("func (m *%s) EXPECT() *%s {", mockedStructName, expectStructName)
	w.Ident()
	w.P("return &%s{", expectStructName)
	w.Ident()
	w.P("m: m,")
	w.EndIdent()
	w.P("}")
	w.EndIdent()
	w.P("}")
	w.P("")

	w.P("func (m *%s) unexpectedCall(method, args string) {", mockedStructName)
	w.Ident()
	w.P("m.t.Helper()")
	w.P("m.t.Fatalf(`Unexpected call to %s.%%s(%%s)`, method, args)", mockedStructName)
	w.EndIdent()
	w.P("}")
	w.P("")

	w.P("type %s struct {", expectStructName)
	w.Ident()
	w.P("m *%s", mockedStructName)
	w.EndIdent()
	w.P("}")
	w.P("")

	for _, f := range res.Methods {
		funcStruct := fmt.Sprintf("%s%sFunc", mockedStructName, f.Name)

		w.P("func (mh *%s) %s() *%s {", expectStructName, f.Name, funcStruct)
		w.Ident()
		w.P("mh.m.f%s = func%s { return }", f.Name, f.Signature())
		w.P("return &%s{m: mh.m}", funcStruct)
		w.EndIdent()
		w.P("}")
		w.P("")

		w.P("type %s struct {", funcStruct)
		w.Ident()
		w.P("m *%s", mockedStructName)
		w.EndIdent()
		w.P("}")
		w.P("")

		if len(f.Results) > 0 {
			w.P("func (f *%s) Return(%s) {", funcStruct, f.Results.IdentWithTypeString(model.IdentTypeResult))
			w.Ident()
			w.P("f.m.f%s = func%s { return %s }", f.Name, f.Signature(), f.Results.IdentString(model.IdentTypeResult))
			w.EndIdent()
			w.P("}")
			w.P("")
		}

		w.P("func (f *%s) Do(do func%s) {", funcStruct, f.Signature())
		w.Ident()
		w.P("f.m.f%s = do", f.Name)
		w.EndIdent()
		w.P("}")
	}
	logger.Printf("Finished generating mock")

	return w.String(), nil
}
