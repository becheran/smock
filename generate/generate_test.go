package generate_test

import (
	"testing"

	"github.com/becheran/smock/generate"
	"github.com/becheran/smock/model"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const expOutput = `// DO NOT EDIT
// Code generated by smock 

package orig_mock

import (
	orig "github.com/becheran/smock/orig"
)

// MockHandler must implement interface orig.Handler
var _ orig.Handler = &MockHandler{}

func NewMockHandler(t interface {
	Fatalf(format string, args ...interface{})
	Helper()
}) *MockHandler {
	return &MockHandler{t: t}
}

type MockHandler struct {
	t interface {
		Fatalf(format string, args ...interface{})
		Helper()
	}
	fTarget func() (r0 int)
}

func (m *MockHandler) Target() (r0 int) {
	if m.fTarget != nil {
		return m.fTarget()
	} else {
		m.unexpectedCall("Target", "")
		return
	}
}

func (m *MockHandler) WHEN() *MockHandlerWhen {
	return &MockHandlerWhen{
		m: m,
	}
}

func (m *MockHandler) unexpectedCall(method, args string) {
	m.t.Helper()
	m.t.Fatalf(` + "`" + `Unexpected call to MockHandler.%s(%s)` + "`" + `, method, args)
}

type MockHandlerWhen struct {
	m *MockHandler
}

func (mh *MockHandlerWhen) Target() *MockHandlerTargetFunc {
	mh.m.fTarget = func() (r0 int) { return }
	return &MockHandlerTargetFunc{m: mh.m}
}

type MockHandlerTargetFunc struct {
	m *MockHandler
}

func (f *MockHandlerTargetFunc) Return(r0 int) {
	f.m.fTarget = func() (r0 int) { return r0 }
}

func (f *MockHandlerTargetFunc) Do(do func() (r0 int)) {
	f.m.fTarget = do
}
`

func TestGenerateMock(t *testing.T) {
	input := model.InterfaceResult{
		PackageName: "orig",
		Name:        "Handler",
		Imports:     []model.Import{{Name: "orig", Path: "github.com/becheran/smock/orig"}},
		Methods:     []model.Method{{Name: "Target", Results: []model.Ident{{Type: "int"}}}},
	}

	res, err := generate.GenerateMock(input)

	require.Nil(t, err)
	assert.Equal(t, expOutput, res)
}
